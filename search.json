[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Text Analysis with R",
    "section": "",
    "text": "Authors: Renata Curty  and Jairo Melo \n\nThis three-part, hands-on workshop series introduces participants to the fundamentals of extracting insights from textual data using R. In Part 1: Text Preprocessing, we focus on cleaning and preparing text for analysis through normalization, noise reduction, stopword removal, tokenization, and lemmatization. Part 2 will delve into core text analysis techniques, including word frequencies, collocations, n-grams, and visualizations such as word clouds. Finally, Part 3 will explore sentiment analysis, applying polarity scoring and emotion detection methods. Throughout the series, we’ll also highlight important caveats and best practices unique to working with textual data.\n\n\nThese lessons are hands-on and are designed to be followed with R and RStudio open. Before starting, please ensure you have the following software installed:\n\nR: We recommend R version 4.3 or newer. Download from CRAN.\nRStudio: We recommend RStudio version 2023.12 or newer. Download from Posit’s website.\n\n\n\n\n\n\n\nNoteHow to update R and RStudio\n\n\n\n\n\nCheck your versions\n\nRStudio:\n\nOn Mac: Go to RStudio -&gt; About RStudio.\nOn Windows: Go to Help -&gt; About RStudio.\n\nR: In the R console, run:\n\n#| eval: false\nR.version.string\nUpdate R\n\nGo to CRAN and download the latest version for your operating system.\nRun the installer. (You don’t need to uninstall older versions—R will install alongside them.)\n\nUpdate RStudio\n\nGo to Posit’s download page.\nDownload and install the newest version for your operating system.\n\nThat’s it! After updating, restart your computer to make sure RStudio finds the latest R.\n\n\n\n\n\n\nFor this lesson we will analyze a dataset of social media posts related to the Apple TV series Severance. The dataset was collected using Brandwatch (via UCSB Library subscription), and it includes posts from the two days following the finales of Season 1 (April 2022) and Season 2 (March 2025). The dataset contains over 5,800 posts stored in a CSV file.\nThe R project containing the dataset and other files is available for download from this link: Severance Dataset. You will need an active UCSB NetID and password to access the file (the same you use for your UCSB email).\n\n\n\nThis level assumes a basic familiarity with R and RStudio. If you are new to R, we recommend you check out the Introduction to Data Analysis with R, particularly the Introduction to R and RStudio section.",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#prerequisites",
    "href": "index.html#prerequisites",
    "title": "Text Analysis with R",
    "section": "",
    "text": "These lessons are hands-on and are designed to be followed with R and RStudio open. Before starting, please ensure you have the following software installed:\n\nR: We recommend R version 4.3 or newer. Download from CRAN.\nRStudio: We recommend RStudio version 2023.12 or newer. Download from Posit’s website.\n\n\n\n\n\n\n\nNoteHow to update R and RStudio\n\n\n\n\n\nCheck your versions\n\nRStudio:\n\nOn Mac: Go to RStudio -&gt; About RStudio.\nOn Windows: Go to Help -&gt; About RStudio.\n\nR: In the R console, run:\n\n#| eval: false\nR.version.string\nUpdate R\n\nGo to CRAN and download the latest version for your operating system.\nRun the installer. (You don’t need to uninstall older versions—R will install alongside them.)\n\nUpdate RStudio\n\nGo to Posit’s download page.\nDownload and install the newest version for your operating system.\n\nThat’s it! After updating, restart your computer to make sure RStudio finds the latest R.",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#access-to-data",
    "href": "index.html#access-to-data",
    "title": "Text Analysis with R",
    "section": "",
    "text": "For this lesson we will analyze a dataset of social media posts related to the Apple TV series Severance. The dataset was collected using Brandwatch (via UCSB Library subscription), and it includes posts from the two days following the finales of Season 1 (April 2022) and Season 2 (March 2025). The dataset contains over 5,800 posts stored in a CSV file.\nThe R project containing the dataset and other files is available for download from this link: Severance Dataset. You will need an active UCSB NetID and password to access the file (the same you use for your UCSB email).",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#r-skill-level",
    "href": "index.html#r-skill-level",
    "title": "Text Analysis with R",
    "section": "",
    "text": "This level assumes a basic familiarity with R and RStudio. If you are new to R, we recommend you check out the Introduction to Data Analysis with R, particularly the Introduction to R and RStudio section.",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "chapters/1.Preprocessing/05_lemmatization.html",
    "href": "chapters/1.Preprocessing/05_lemmatization.html",
    "title": "Lemmatization",
    "section": "",
    "text": "Also known as word reduction, lemmatization is the process of transforming words into their base or dictionary form (lemma) to identify similarities in meaning and usage across different contexts. Take the word “run” as an example. It can appear in various forms like “ran”, “runs”, “running”, and “runner”. But the variations don’t stop there, as it includes complex forms like “outrun”, “overrun”, or “underrun”. These variations make it challenging for computers to process natural language effectively unless they can recognize that these words are related. That’s where lemmatization comes in; it helps machines group related words together by reducing them to a common root present in the dictionary, enabling better understanding and analysis of text.\nYou might be wondering: what about stemming? Stemming is a simpler but more aggressive process that removes prefixes and suffixes to reduce words to their root forms. It is generally considered less precise than lemmatization because it can sometimes produce meaningless words. For example, while “ran” and “runs” would correctly stem to “run,” the word “running” would be reduced to “runn.”\nFor this reason, we will stick with lemmatization and skip stemming in our pipeline. That said, if you need to process very large volumes of text and want a faster, more efficient approach, stemming could be a reasonable alternative.\nAn important thing to consider is that we look into words as separate units (tokens) as we saw in the previous episode. For example, think about the word “leaves”. That could both represent the plural of the noun “leaf” or the verb in third person for the word “leave”. That is a good reminder of always remember to apply part of speech (POS) because lemmatization algorithms utilize a lexicon with linguistic rules based on pre-determined tags to avoid misinterpretation.\nAlright, back to our pipeline, we will now convert words to their dictionary form, remove any remaining noise, and finalize our preprocessing steps.\nWe will be using the lemmatize_words() function from the textstem package. And add a new column called word_lemmatized to your comments_clean dataset, containing the base form of each word:\nGreat! Let’s take a look at the lemmatized data frame. For example, words such as “telling” and “captivating” were converted into “tell” and “captivate”.\nWait a second! If we look closely, we’ll notice an outlier lemma. Do you see the number two in the last row of the screenshot above? This is a known issue with the textstem package. While it hasn’t been fully resolved yet, we can apply a workaround to address it:\nLet’s see that row (20) once again in the new lemmatized_nonumbers dataframe we have created.\nAlright! Problem solved. Keep in mind, however, this would apply to most words referring to numbers, but to save us time let’s address only this specifc case.",
    "crumbs": [
      "Lemmatization"
    ]
  },
  {
    "objectID": "chapters/1.Preprocessing/05_lemmatization.html#rebuilding-sentences",
    "href": "chapters/1.Preprocessing/05_lemmatization.html#rebuilding-sentences",
    "title": "Lemmatization",
    "section": "Rebuilding Sentences",
    "text": "Rebuilding Sentences\nBut we’re not done yet. After tokenization, our data consists of individual words. We still need to reconstruct full sentences from these lemmatized words so that each row represents a complete piece of text. To ensure the words are reassembled in the correct order for each original text, we rely on the ID column. Having an ID column is crucial because it allows us to track which words belong to which original text, preventing confusion or misalignment when reconstructing sentences, especially in large or complex datasets.\n# Reconstruct sentences from lemmatized words\npreprocessed &lt;- lemmatized %&gt;%\n  group_by(id, text) %&gt;%\n  summarise(text_preprocessed = paste(word, collapse = \" \"), .groups = \"drop\")\nAfter you use group_by(id, text), each group contains all the lemmatized words that belong to the same original text. The summarise() function then takes each group and creates one summary row per group.\nInside summarise, text_preprocessed = paste(word, collapse = \" \") takes all the words in the group and joins them together into a single string, with a space between each word. This produces a full sentence (or comment) instead of separate words. We will also ensure to describe a different path to save our progress to a folder named preprocessed under the data folder.",
    "crumbs": [
      "Lemmatization"
    ]
  },
  {
    "objectID": "chapters/1.Preprocessing/05_lemmatization.html#saving-your-work-for-analysis",
    "href": "chapters/1.Preprocessing/05_lemmatization.html#saving-your-work-for-analysis",
    "title": "Lemmatization",
    "section": "Saving your Work for Analysis",
    "text": "Saving your Work for Analysis\nlet’s save it as a new file named comments_preprocessed:\n# Select only important columns\noutput &lt;- preprocessed %&gt;%\n  select(id, text_preprocessed)\n\n# Save to CSV\nwrite.csv(output, \"./data/preprocessed/comments_preprocessed.csv\")",
    "crumbs": [
      "Lemmatization"
    ]
  },
  {
    "objectID": "chapters/1.Preprocessing/05_lemmatization.html#before-we-go",
    "href": "chapters/1.Preprocessing/05_lemmatization.html#before-we-go",
    "title": "Lemmatization",
    "section": "Before we go",
    "text": "Before we go\nIf you notice that the output object saved as comments_preprocessed contains one fewer row (observation) than the original dataset, this is because, after applying normalization and stopword removal with the Snowball Lexicon, the comment associated with ID \"s2_0998\" became an empty string.\n\nWell done! That concludes all our preprocessing steps. Let’s now cover some important considerations for your future text preprocessing projects.",
    "crumbs": [
      "Lemmatization"
    ]
  },
  {
    "objectID": "chapters/1.Preprocessing/03_tokenization.html",
    "href": "chapters/1.Preprocessing/03_tokenization.html",
    "title": "Word Tokenization",
    "section": "",
    "text": "Tokenization in NLP differs from applications in security and blockchain. It corresponds to the action of breaking down text into smaller pieces (aka tokens). It is a foundational process in the digital world, allowing machines to interpret and analyze large volumes of text data. By dividing text into smaller, more manageable units, it enhances both the efficiency and accuracy of data processing.\nText can be tokenized into sentences, word, subwords or even characters, depending on project goals and analysis plan. Here is a summary of these approaches:\n\n\n\n\n\n\n\n\n\nType\nDescription\nExample\nCommon Use Cases\n\n\n\n\nSentence Tokenization\nSplits text into individual sentences\n\"I love NLP. It's fascinating!\" → [\"I love NLP.\", \"It's fascinating!\"]\nIdeal for tasks like summarization, machine translation, and sentiment analysis at the sentence level\n\n\nWord Tokenization\nDivides text into individual words\n\"I love NLP\" → [\"I\", \"love\", \"NLP\"]\nWorks well for languages with clear word boundaries, such as English\n\n\nCharacter Tokenization\nBreaks text down into individual characters\n\"NLP\" → [\"N\", \"L\", \"P\"]\nUseful for languages without explicit word boundaries or for very fine-grained text analysis\n\n\nSubword Tokenization\nDecomposes words into smaller parts, like prefixes, suffixes, or common morphemes (the smallest units of meaning in a language)\n\"subword tokenization\" → [\"sub\", \"word\", \"token\", \"ization\"]\nEffective for handling rare or unknown words and languages with complex word formation\n\n\n\nSome might recall, that along with the popularization and excitement around ChaGPT, there were also a few warnings about the LLMs failing in answering correctly how many “r” letters does the word strawberry have. Can you guess why?\n\n\n\nImage from: OpenAI Community Forum [829618]\n\n\nAlthough this issue has been resolved in later versions of the model, it was originally caused by subword tokenization. In this case, the tokenizer would split “strawberry” into “st,” “raw,” and “berry.” As a result, the model would incorrectly count the letter “r” only within the “berry” token. This illustrates how the tokenization approach directly affects how words are segmented and how their components are interpreted by the model.\nWhile this is beyond the scope of the workshop, it’s important to note that some advanced AI models use neural networks to dynamically determine token segmentation. Rather than relying on fixed rules, these models can adapt based on the contextual cues within the text. However, tokenization remains inherently limited by the irregular, organic, and often unpredictable nature of human language.\nLet’s go back to our dataset and apply tokenization. We will use the `tidytext` function unnest_tokens(), which splits the text in a specified column into individual tokens (here, words), creating one row per token while keeping other data intact. The first argument (word) names the new column for tokens, and the second (text_cleaned) specifies the text column to tokenize. In short, it turns each word from text_cleaned into its own row in a new column called word in a new dataframe named tokenized.\n# Tokenization\ntokenized &lt;- comments %&gt;%\n  unnest_tokens(word, text_cleaned)\nGreat! We’ve just tokenized each individual comment (text string) in our dataset into individual words, giving us, as noted in the environment a total of 121,360 tokens in the tokenized dataframe!\n\nIf you’ve looked at the token output, you may have noticed that some of these tokens are common but less meaningful words, like to, it, and is. Don’t worry; we’ll take care of those in the next step: stop word removal.",
    "crumbs": [
      "Word Tokenization"
    ]
  },
  {
    "objectID": "chapters/1.Preprocessing/01_introduction.html",
    "href": "chapters/1.Preprocessing/01_introduction.html",
    "title": "Introduction to Text Preprocessing",
    "section": "",
    "text": "Text analysis is about digging into written words to find meaning, spotting patterns, tracking sentiment, or identifying key topics and themes. It’s essentially the “what does this text tell us?” part of the process. Text analysis turns unstructured words into structured insights. Every day, countless emails, news articles, social media content, scientific literature, and reports are produced, hiding patterns, opinions, and signals that numbers alone can’t capture. By applying computational text analysis, we can uncover trends, measure public sentiment, compare perspectives, and extract meaning from massive collections of information that would otherwise feel overwhelming.\nText preprocessing is the set of steps used to clean, standardize, and structure raw text before it can be meaningfully analyzed. This may include removing punctuation, normalizing letter case, eliminating stop words, breaking text into tokens (words or sentences), and reducing words to their base forms through lemmatization. Preprocessing reduces noise and inconsistencies in the text, making it ready for computational analysis.\nNatural Language Processing (NLP) provides the computational methods that make text analysis possible. It is a branch of artificial intelligence that enables computers to understand, interpret, and generate human language. NLP techniques include part-of-speech tagging, named entity recognition, sentiment detection, topic modeling, and transforming words into numerical representations for analysis.\nThese three elements are co-dependent and work together. Preprocessing prepares messy text for analysis, NLP provides the computational tools to process and interpret the text, and text analysis applies these insights to answer meaningful questions. Without preprocessing, NLP models struggle with noise; without NLP, text analysis would be limited to surface-level counts; and without text analysis, NLP would have little purpose beyond technical processing. Together, they transform raw text into structured, actionable insights.From messy to analysis-ready text\nOf course, text isn’t quite as “analysis-ready” as numbers. Have you ever looked at raw text data and thought, where do I even start? That’s the challenge: before computers can process it meaningfully, text usually needs some cleaning and preparation. Before text can be analyzed computationally, it needs to be standardized. Computers see “Happy,” “happy,” and “HAPPY!!!” as different words — preprocessing fixes that.\nIt’s extra work, but it’s also the foundation of any meaningful analysis. The exciting part is what happens next; once the text is shaped and structured, it can reveal insights you’d never notice just by skimming. And here’s the real advantage: computers can process enormous amounts of text not only faster but often more effectively than humans, allowing us to see patterns and connections that would otherwise stay hidden.",
    "crumbs": [
      "Introduction to Text Preprocessing"
    ]
  },
  {
    "objectID": "chapters/1.Preprocessing/01_introduction.html#getting-things-started",
    "href": "chapters/1.Preprocessing/01_introduction.html#getting-things-started",
    "title": "Introduction to Text Preprocessing",
    "section": "Getting Things Started",
    "text": "Getting Things Started\nThe data we pulled for this exercise comes from real social media posts, meaning they are inherently messy, and we know that even before going in. Because it is derived from natural language, this kind of data is unstructured, often filled with inconsistencies and irregularities.\nBefore we can apply any meaningful analysis or modeling, it’s crucial to visually inspect the data to get a sense of what we’re working with. Eyeballing the raw text helps us identify common patterns, potential noise, and areas that will require careful preprocessing to ensure the downstream tasks are effective and reliable.\n\nGetting Files and Launching RStudio\nTime to launch RStudio and our example! Click on this link to download the text-preprocessing subfolder, from the folder text-analysis-series. Among other files, this subfolder contains the dataset we will be using comments.csv, a worksheet in qmd, a Quarto extension (learn more about Quarto), named preprocessing-workbook.qmd where we will be performing some coding, and an renv.lock(learn more about Renv) file listing all the R packages (and their versions) we’ll use during the workshop.\nThis setup ensures a self-contained environment, so you can run everything needed for the session without installing or changing any packages that might affect your other R projects.\nAfter downloading this subfolder, double click on the project file text-preprocessing.Rproj to launch Rstudio. Look for and open the file preprocessing-workbook.qmd on your Rstudio environment.\n\n\nSetting up the environment with renv\nNext, we will need to install the package `renv` so you can setup the working environment correctly with all the packages and dependencies we will need. On the console, type:\ninstall.packages(\"renv\")\nThen, still in the console, we will restore it, which will essentially installs packages in an R project to match the versions recorded in the project’s renv.lock file we have shared with you.\nrenv::restore()\n\n\n\n\n\n\nWarning\n\n\n\nMatrix Package Incompatible with R\nIf you encounter incompatibility issues with the Matrix package (or any other) due to your R version, you can explicitly install the package by running the following in your console:\nrenv::install(\"Matrix\")\nNext, update your renv.lock file to reflect this version by running:\nrenv::snapshot()\n\n\n\n\nLoading Packages & Inspecting the Data\nLet’s start by loading all the required packages that are pre-installed in the project:\nlibrary(tidyverse)    # general data manipulation\nlibrary(tidytext)     # tokenization and text processing\nlibrary(stringr)      # string manipulation\nlibrary(stringi)      # emoji handling\nlibrary(dplyr)        # data wrangling\nlibrary(textclean)    # expand contractions\nlibrary(emo)          # emoji dictionary\nlibrary(textstem)     # lemmatization\nAfter running it, you should get:\n\nAlright! With all the necessary packages loaded, let’s take a look at the dataset we’ll be working with:\n# Inspecting the data\ncomments &lt;- readr::read_csv(\"./data/raw/comments.csv\")\nWhich should show our dataset contains 5877 comments and two columns and display the comments dataset to our environment:\n\nIn the workbook, you’ll notice that we’ve pre-populated some chunks below to save you from the tedious typing. Don’t worry about them for now, we’ll come back to them shortly.\n\n\n\n\n\n\nNote💬 Discussion\n\n\n\nWorking in pairs or trios, look briefly by double clicking comments dataset in the environment panel. Then, discuss could be potential challenges of analyzing this text on its current form. What could be potential areas of friction that could compromise the results?",
    "crumbs": [
      "Introduction to Text Preprocessing"
    ]
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About RDS",
    "section": "",
    "text": "Research Data Services (RDS) helps UCSB researchers manage and preserve their research data in a more effective and reproducible way through:\n\nConsultations\nLong-term engagements\nInstructional workshops.\n\nOur team offers support across the research data lifecycle, from pre-project planning to post-project archival, connecting researchers with both locally- and externally-provided resources, data management systems and curation services. Our goal is to ensure that all research data is well-described, FAIR (Findable, Accessible, Interoperable, Reusable), as well as sustainable and preservable, and that researchers receive scholarly credit for sharing and publishing their data.\nWe recommend you explore the Research Computing and Data website (https://rcd.ucsb.edu ) maintained by our department for campus-wide tools, recommendations, events, communities and learning resources.\nContact us if you have any questions: rds@library.ucsb.edu",
    "crumbs": [
      "About RDS"
    ]
  },
  {
    "objectID": "about.html#ways-we-can-help-you",
    "href": "about.html#ways-we-can-help-you",
    "title": "About RDS",
    "section": "",
    "text": "Research Data Services (RDS) helps UCSB researchers manage and preserve their research data in a more effective and reproducible way through:\n\nConsultations\nLong-term engagements\nInstructional workshops.\n\nOur team offers support across the research data lifecycle, from pre-project planning to post-project archival, connecting researchers with both locally- and externally-provided resources, data management systems and curation services. Our goal is to ensure that all research data is well-described, FAIR (Findable, Accessible, Interoperable, Reusable), as well as sustainable and preservable, and that researchers receive scholarly credit for sharing and publishing their data.\nWe recommend you explore the Research Computing and Data website (https://rcd.ucsb.edu ) maintained by our department for campus-wide tools, recommendations, events, communities and learning resources.\nContact us if you have any questions: rds@library.ucsb.edu",
    "crumbs": [
      "About RDS"
    ]
  },
  {
    "objectID": "chapters/1.Preprocessing/02_normalization.html",
    "href": "chapters/1.Preprocessing/02_normalization.html",
    "title": "Normalization & Noise Reduction",
    "section": "",
    "text": "As previously mentioned, in order to perform accurate and reliable analysis, we need to “take out the garbage” first by preprocessing the text to clean, standardize, and structure the input data. These steps help reduce noise and improve the model’s accuracy.\nBelow we use another analogy to illustrate the impact of noise on data analysis outcomes. Imagine a tree that is slowly dying. On the surface, its leaves may still appear green, but closer inspection reveals branches that are brittle, bark that is cracking, and roots that are struggling to find nourishment. If we only focus on the healthy-looking leaves, we might draw a misleading conclusion about the tree’s overall condition. Similarly, in text analysis, raw data often contains “noise,” such as irrelevant words, inconsistent formatting, or errors, which can obscure meaningful patterns. If we feed this noisy data directly into an analysis, the results can be skewed, incomplete, or misleading, just as judging the tree’s health by its leaves alone would be.\nJust as a gardener would prune dead branches, enrich the soil, and care for the roots to revive the tree, data analysts perform preprocessing steps to clean, standardize, and structure the text. By removing noise and focusing on the core content, we give the analysis the best chance to reveal true insights, uncover trends, and support reliable conclusions. In short, the quality of our “data garden” directly determines the health of the insights it produces.\n\nThe main goal of normalization is to remove irrelevant content and standardize the data in order to reduce noise. Below are some key actions we’ll be performing during this workshop:\n\n\n\n\n\n\n\nAction\nWhy it matters?\n\n\n\n\nRemove URLs\nURLs often contain irrelevant noise and don’t contribute meaningful content for analysis.\n\n\nRemove Punctuation & Symbols\nPunctuation marks and other symbols including those extensively used in social media for mentioning (@) or tagging (#) rarely adds value in most NLP tasks and can interfere with tokenization (as we will cover in a bit) or word matching.\n\n\nRemove Numbers\nNumbers can be noise in most contexts unless specifically relevant (e.g., in financial or medical texts) don’t contribute much to the analysis. However, in NLP tasks they are considered important, there might be considerations to replace them with dummy tokens (e.g. &lt;NUMBER&gt;), or even converting them into their written form (e.g, 100 becomes one hundred).\n\n\nNormalize Whitespaces\nEnsures consistent word boundaries and avoids issues during tokenization or frequency analysis.\n\n\nConvert to Lowercase\nPrevents case sensitivity from splitting word counts due to case variations (e.g., “AppleTV” ≠ “APPLETV” ≠ “appleTV” ≠ “appletv”), improving model consistency.\n\n\nConvert Emojis to Text\nEmojis play a unique role in text analysis, as they often convey sentiment. Rather than removing them, we will convert them into their corresponding text descriptions.\n\n\n\n\n\n\n\n\n\nNote🧠 Knowledge Check\n\n\n\nIn pairs or groups of three, identify the techniques you would consider using to normalize and reduce noise in the following sentence:\n“OMG!! 😱 I can’t believe it… This is CRAZY!!! #unreal 🤯”\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\nHow many techniques could you identify? Bingo if you have spotted all four!\nAfter applying them the sentence should look like:\nomg [face scream in fear] I can not believe it this is crazy unreal [exploding head]\n\n\n\n\n\nA caveat when working with emojis is that they are figurative and highly contextual. Also, there may be important generational and cultural variability in how people interpret them. For example, some countries may use the Folded Hands Emoji (🙏) as a sign of thank you where others may seem as religious expression. Also, some may use it in a more positive way as gratitude, hope or respect, or in a negative context, where they might be demonstrating submission or begging.\nYou might have noticed based on the example above that emojis are converted to their equivalent CLDR (common, human-readable name) based on this emoji unicode list, which are not as nuanced and always helpful to detect sentiment. While not always perfect, that is an important step to normalize the data and we will see how this process looks like later on this episode.",
    "crumbs": [
      "Normalization & Noise Reduction"
    ]
  },
  {
    "objectID": "chapters/1.Preprocessing/02_normalization.html#the-role-of-regular-expressions",
    "href": "chapters/1.Preprocessing/02_normalization.html#the-role-of-regular-expressions",
    "title": "Normalization & Noise Reduction",
    "section": "The Role of Regular Expressions",
    "text": "The Role of Regular Expressions\nRegular expressions (regex) are powerful tools for pattern matching and text manipulation. They allow you to identify, extract, or replace specific sequences of characters in text, such as email addresses, URLs, hashtags, or user mentions. In text cleaning, regex is essential for reducing noise by removing unwanted elements like punctuation, special symbols, or repeated whitespace, which can interfere with analysis. By systematically filtering out irrelevant or inconsistent text, regex helps create cleaner, more structured data, improving the accuracy of downstream tasks like sentiment analysis, topic modeling, or machine learning.\nEven though we won’t dive into the syntax or practice exercises here, being aware of regex and its capabilities can help you understand how text preprocessing works behind the scenes and guide you toward resources to learn it on your own.\nWorking with regular expressions might require some trial and error, especially when you are working with a large and highly messy corpus. To make things easier and make the lesson less typing-intensive, we’ve pre-populated the workbook with regex patterns noted below and will provide a clear explanation of how they are expected to function, so you can follow along confidently.\nurl_pattern &lt;- \"http[s]?://[^\\\\s,]+|www\\\\.[^\\\\s,]+\"\nhidden_characters &lt;- \"[\\u00A0\\u2066\\u2067\\u2068\\u2069]\"\napostrophes &lt;- (\"[‘’‛ʼ❛❜＇`´′]\")\nmentions &lt;- \"@[A-Za-z0-9_]+\"\nhashtag_splitter &lt;- \"(?&lt;![#@])([a-z])([A-Z])\"\npunctuation &lt;- \"[[:punct:]“”‘’–—…|+]\"\nnumbers &lt;- \"[[:digit:]]\"\nrepeated_chars &lt;- \"(.)\\\\1{2,}\"\nsingle_characters &lt;- \"\\\\b[a-zA-Z]\\\\b\"\nLet’s run this chunk with pattern variables for now, we will get back to each line when covering their corresponding code in our normalization and noise reduction chunk. Notice this patterns will show in our environment as seen below:\n\n\n\n\n\n\n\nTipGet Help with Regex\n\n\n\nTesting regular expressions is essential for accuracy and reliability, since complex patterns often produce unexpected results. Careful testing ensures your regex matches the intended text, rejects invalid inputs, and performs efficiently, while also revealing potential bugs before they impact your system. To make testing more effective, use tools like Regex101 or the Coder Pad cheatsheet or and be sure to check tricky border cases that might otherwise slip through.\n\n\n\n\n\n\n\n\nCautionThe Order Matters!\n\n\n\nBefore we start performing text normalization and noise reduction, we should caution you that the order of steps matters because each transformation changes the text in a way that can affect subsequent steps. Doing things in a different order can lead to different results, and sometimes even incorrect or unexpected outcomes. For example, if we remove punctuation before expanding contractions, \"can't\" might turn into \"cant\" instead of \"cannot\", losing the correct meaning.\n\n\nAlright, let’s return to our workbook to dive into cleaning and normalization. The order in which we apply these steps matters, each transformation builds on the previous one to make the data more consistent, structured, and analysis-ready. Keep in mind, however, that the pipeline we’ll use here is unlikely to perfectly fit every type of textual data; the best approach always depends on your specific dataset and project goals.",
    "crumbs": [
      "Normalization & Noise Reduction"
    ]
  },
  {
    "objectID": "chapters/1.Preprocessing/02_normalization.html#creating-a-new-data-frame",
    "href": "chapters/1.Preprocessing/02_normalization.html#creating-a-new-data-frame",
    "title": "Normalization & Noise Reduction",
    "section": "0. Creating a New Data Frame",
    "text": "0. Creating a New Data Frame\nThe first step would be to create a new data frame called comments_clean and adding a clean_text column to it:\n# Create a new column for the output clean text\ncomments_clean &lt;- comments %&gt;%\n  mutate(\n    clean_text = text %&gt;%\nDon’t forget the pipe operator `%` since we want to pass the result of this function as an input to the next, as we continue working on the code chunk.",
    "crumbs": [
      "Normalization & Noise Reduction"
    ]
  },
  {
    "objectID": "chapters/1.Preprocessing/02_normalization.html#removing-urls",
    "href": "chapters/1.Preprocessing/02_normalization.html#removing-urls",
    "title": "Normalization & Noise Reduction",
    "section": "1. Removing URLs",
    "text": "1. Removing URLs\nThis comes first because URLs can contain other characters (like punctuation or digits) that you’ll handle later, so removing them early prevents interference. Because we have a great variation in format (e.g., http://, https://, or www.) we had to define a regex pattern, where:\n\nhttp[s]?:// → matches “http://” or “https://”\n[^\\\\s,]+ → matches one or more characters that are not spaces or commas (the rest of the URL)\n| → OR operator; matches either the left or right pattern\nwww\\.[^\\\\s,]+ → matches URLs starting with “www.” followed by non-space/non-comma characters\n\nSince we already have the URL pattern, we can use str_replace_all() from the stringr package to replace all matching URLs with an empty string in our text.\n# Remove URLs\nstr_replace_all(url_pattern, \"\") %&gt;%",
    "crumbs": [
      "Normalization & Noise Reduction"
    ]
  },
  {
    "objectID": "chapters/1.Preprocessing/02_normalization.html#hidden-characters",
    "href": "chapters/1.Preprocessing/02_normalization.html#hidden-characters",
    "title": "Normalization & Noise Reduction",
    "section": "2. Hidden Characters",
    "text": "2. Hidden Characters\nHidden characters are one of the trickiest challenges in text preprocessing. These are characters that aren’t immediately visible when you view text, but they can interfere with analysis, parsing, or modeling. Hidden characters include things like non-breaking spaces, zero-width spaces, invisible control characters (like carriage returns \\r, line feeds \\n, tabs \\t), Unicode invisible formatting characters, and even special symbols copied from PDFs or web pages.\nIn practice, these characters can cause subtle errors. For example, they can make two strings appear different even though they look identical, break tokenization, or create issues when matching patterns with regular expressions. In natural language processing (NLP), they can inflate vocabulary size unnecessarily, confuse word embeddings, or lead to inaccurate frequency counts.\nTo ensure they won’t cause us future problems, we have included a regex pattern that matches certain hidden or invisible Unicode characters in text. Here’s a breakdown:\n\n[] → This denotes a character class in regex, meaning it will match any single character listed inside.\n\\u00A0 → This is a non-breaking space. Unlike a normal space, it doesn’t allow line breaks. It often appears when copying text from websites or PDFs.\n\\u2066, \\u2067, \\u2068, \\u2069 → These are Unicode “isolate” control characters used for bidirectional text handling (like in right-to-left languages). They are invisible and generally unnecessary for text analysis.\n\nLet’s now call that variable and enter some code to address that:\n# Replace hidden/special characters with space\nstr_replace_all(hidden_characters, \" \") %&gt;%",
    "crumbs": [
      "Normalization & Noise Reduction"
    ]
  },
  {
    "objectID": "chapters/1.Preprocessing/02_normalization.html#handling-apostrophes",
    "href": "chapters/1.Preprocessing/02_normalization.html#handling-apostrophes",
    "title": "Normalization & Noise Reduction",
    "section": "3. Handling Apostrophes",
    "text": "3. Handling Apostrophes\nThis step helps clean up text by making sure all apostrophes are consistent, rather than a mix of fancy Unicode versions. Applying it to the text column in our comments dataset should look like. In this case, the pattern “[’‘ʼ]” looks for several different kinds of apostrophes and backticks; like the left and right single quotes, the modifier apostrophe, and the backtick. Each of those gets replaced with a simple, standard apostrophe (’`) when we apply the function below:\n# Standardize apostrophes\nstr_replace_all(apostrophes, \"'\") %&gt;%\nNote that once again, we are calling the stored variable with the regex containing different forms of apostrophes, especially from social media, PDFs, or copy-pasted content.",
    "crumbs": [
      "Normalization & Noise Reduction"
    ]
  },
  {
    "objectID": "chapters/1.Preprocessing/02_normalization.html#expanding-contractions",
    "href": "chapters/1.Preprocessing/02_normalization.html#expanding-contractions",
    "title": "Normalization & Noise Reduction",
    "section": "4. Expanding Contractions",
    "text": "4. Expanding Contractions\nNow that we have normalized variations of apostrophes, we can properly handle contractions. In everyday language, we often shorten words: can’t, don’t, it’s. These make speech and writing flow more easily, but they can cause confusion for Natural Language Processing (NLP) models. Expanding contractions, such as changing can’t to cannot or it’s to it is, helps bring clarity and consistency to the text because NLP models treat don’t and do not as completely different words, even though they mean the same thing. Also, words like cant, doesnt, and whats lose their meaning. Expanding contractions reduces this inconsistency and ensures that both forms are recognized as the same concept. Expanding it to is not happy makes the negative sentiment explicit, which is especially important in tasks like sentiment analysis.\nSo, while it may seem like a small step, it often leads to cleaner data, leaner models, and more accurate results. First, however, we need to ensure that apostrophes are handled correctly. It’s not uncommon to encounter messy text where nonstandard characters are used in place of the straight apostrophe (’). Such inconsistencies are very common and can disrupt contraction expansion.\n\n\n\n\n\n\n\n\nCharacter\nUnicode\nNotes\n\n\n\n\n'\nU+0027\nStandard straight apostrophe, used in most dictionaries\n\n\n’\nU+2019\nRight single quotation mark (curly apostrophe)\n\n\n‘\nU+2018\nLeft single quotation mark\n\n\nʼ\nU+02BC\nModifier letter apostrophe\n\n\n`\nU+0060\nGrave accent (sometimes typed by mistake)\n\n\n\nTo perform this step we will be using the function replace_contraction from the textclean package to make sure that words like “don’t” become “do not”, by adding the following line to our code chunk:\n# Expand contractions (e.g., \"don't\" → \"do not\")\nreplace_contraction() %&gt;%",
    "crumbs": [
      "Normalization & Noise Reduction"
    ]
  },
  {
    "objectID": "chapters/1.Preprocessing/02_normalization.html#removing-mentions",
    "href": "chapters/1.Preprocessing/02_normalization.html#removing-mentions",
    "title": "Normalization & Noise Reduction",
    "section": "5. Removing Mentions",
    "text": "5. Removing Mentions\nContinuing with our workflow, we will now handle direct mentions and usernames in our dataset, as they do not contribute relevant information to our analysis. We will use a function to replace all occurrences of usernames preceded. Since we have pre-populated the regular expression and stored it in the variable “mentions”, mentions &lt;- \"@[A-Za-z0-9_]+\" we will only need to add that we want to replace it with an empty string and remove them.\n# Remove mentions (@username)\nstr_replace_all(mentions, \"\") %&gt;%",
    "crumbs": [
      "Normalization & Noise Reduction"
    ]
  },
  {
    "objectID": "chapters/1.Preprocessing/02_normalization.html#splitting-hashtags",
    "href": "chapters/1.Preprocessing/02_normalization.html#splitting-hashtags",
    "title": "Normalization & Noise Reduction",
    "section": "6. Splitting Hashtags",
    "text": "6. Splitting Hashtags\nHashtags are a powerful tool in social media and online communication, serving as a way to categorize content, highlight topics, and increase visibility. By prefixing a word or phrase with #, users can link their posts to a broader conversation, making it easier for others to discover and engage with content on that topic. Hashtags also act as a keyword system, allowing researchers and analysts to track trends, measure sentiment, or analyze public discussions around specific themes. In text analysis, properly handling hashtags ensures that the meaningful content within them is captured, improving tokenization, searchability, and overall insights from the data. They effectively turn user-generated text into a structured source of topical information that can be leveraged for both social and analytical purposes.\nHashtags are often written as one long string with no spaces, e.g., #SeveranceIsFire. Splitting them into separate words not only makes it human-readable and easier to understand, but also ensure meaningful tokes and improves text analysis accuracy.\nWhile some researchers might want to separate them from the text for further analysis, we can also split concatenated words in hashtags or camelCase text by inserting a space between them. In our regex pattern hashtag_splitter, we have:\n\n(?&lt;![#@]): negative lookbehind to avoid splitting right after # or @, preserving hashtags and mentions.\n([a-z])([A-Z]): captures lowercase followed by uppercase letters, identifying camelCase word boundaries.\n\nWe can call that pattern and use the string replacement function to adds the space between words while keeping the letters themselves intact, by adding the following to our code chunk:\n# Split camelCase hashtags (optional)\nstr_replace_all(hashtag_splitter, \"\\\\1 \\\\2\") %&gt;%\nIn simple terms, the \"\\1 \\2\" inserts the first captured piece, adds a space, and then inserts the second captured piece.\nYou might be asking, “wait a minute but what about the hastag (#) itself?”. It is a valid question, but not to worry, we will take care of that later when handling symbols.",
    "crumbs": [
      "Normalization & Noise Reduction"
    ]
  },
  {
    "objectID": "chapters/1.Preprocessing/02_normalization.html#converting-to-lowercase",
    "href": "chapters/1.Preprocessing/02_normalization.html#converting-to-lowercase",
    "title": "Normalization & Noise Reduction",
    "section": "7. Converting to Lowercase",
    "text": "7. Converting to Lowercase\nHaving all text converted to lowercase will be our next step, by adding the following line to our code chunk:\n# Convert to lowercase\nstr_to_lower() %&gt;%",
    "crumbs": [
      "Normalization & Noise Reduction"
    ]
  },
  {
    "objectID": "chapters/1.Preprocessing/02_normalization.html#cleaning-punctuation-symbols-and-numbers",
    "href": "chapters/1.Preprocessing/02_normalization.html#cleaning-punctuation-symbols-and-numbers",
    "title": "Normalization & Noise Reduction",
    "section": "8. Cleaning Punctuation, Symbols and Numbers",
    "text": "8. Cleaning Punctuation, Symbols and Numbers\nAlright, time to remove punctuation and symbols, and then numbers.\nBut first, last break it down, the punctuation regex pattern, where [[:punct:]] is character class in regex that matches any standard punctuation character, including: ! ” # $ % & ’ ( ) * + , - . / : ; &lt; = &gt; ? @ [  ] ^ _ ` { | } ~. To be safe and because our dataset is really messy, we added extra characters (“”‘’–—…|+) to catch some special quotes, dashes, ellipsis, and symbols that [[:punct:]] might miss. Calling that variable, we can remove them by adding to our code:\n# Remove punctuation\nstr_replace_all(punctuation, \" \") %&gt;%\nNext, last clear some numbers by adding [[:digit:]]+. This is the regex pattern matches any single digit (0–9) and + means one or more digits in a row. So it matches sequences like 7, 42, 2025, etc:\n# Remove digits\nstr_replace_all(\"[[:digit:]]+\", \" \") %&gt;%",
    "crumbs": [
      "Normalization & Noise Reduction"
    ]
  },
  {
    "objectID": "chapters/1.Preprocessing/02_normalization.html#handling-elongation",
    "href": "chapters/1.Preprocessing/02_normalization.html#handling-elongation",
    "title": "Normalization & Noise Reduction",
    "section": "9. Handling Elongation",
    "text": "9. Handling Elongation\nIn user-generated content, it’s common to see repeated letters used for emphasis (e.g., “Amaaaazing,” “Loooove”). For that, we have the regex pattern repeated_chars &lt;- \"(.)\\1{2,}\", where:\n\n(.): captures group that matches any single character (except line breaks, depending on regex flavor). The . is a wildcard. The parentheses () capture whatever character matched for later reference.\n\\\\1: refers to “whatever was matched by the first capturing group.” In other words, it matches the same character again.\n{2,}: means “repeat the previous element at least 2 times.”\n\nPutting it together (.)\\\\1{2,} matches any character that repeats 3 or more times consecutively. Why 3? Because the first occurrence is matched by (.) and {2,} requires at least 2 more repetitions, so total = 3+.\nBecause the pattern is already in our workbook, we can simply add:\n# Normalize repeated characters (e.g., loooove → love)\nstr_replace_all(repeated_chars, \"\\\\1\") %&gt;%\nCan you guess what \"\\1\" does? It uses the character we captured earlier, keeping it in the text.",
    "crumbs": [
      "Normalization & Noise Reduction"
    ]
  },
  {
    "objectID": "chapters/1.Preprocessing/02_normalization.html#convert-emojis-to-text",
    "href": "chapters/1.Preprocessing/02_normalization.html#convert-emojis-to-text",
    "title": "Normalization & Noise Reduction",
    "section": "10. Convert Emojis to Text",
    "text": "10. Convert Emojis to Text\nOkay, now we’ll convert emojis into their text descriptions to make them machine-readable, using the emoji package to help with this step. We need to first load the emoji dictionary:\n\nGetting the emoji dictionary\n# Load the emoji dictionary\nemoji_dict &lt;- emo::jis[, c(\"emoji\", \"name\")]\nemoji_dict\nTake a look at the emoji dictionary we loaded into our RStudio environment. It’s packed with more emojis and some surprising meanings than you might expect.\nWe will then write a separate function to deal with those emojis in our dataset:\n# Function to replace emojis in text with their corresponding names\nreplace_emojis &lt;- function(text, emoji_dict) {\n  stri_replace_all_fixed(\n    str = text,                  # The text to process\n    pattern = emoji_dict$emoji,  # The emojis to find\n    replacement = paste0(emoji_dict$name, \" \"), # Their corresponding names\n    vectorize_all = FALSE        # element-wise replacement in a same string\n  )\n}\nWait, we are not done yet! We still have to add the replace_emojis function, based on our loaded dictionary, into our code chunk. This will replace the emojis with their corresponding text on our dataset:\n# Replace emojis with textual description (function - see above)\nreplace_emojis(emoji_dict) %&gt;%\nNeat! Let’s re-run the code chunk and check it once again. With emojis taken care of, we can now apply the next and final normalization and noise reduction step.",
    "crumbs": [
      "Normalization & Noise Reduction"
    ]
  },
  {
    "objectID": "chapters/1.Preprocessing/02_normalization.html#removing-single-characters",
    "href": "chapters/1.Preprocessing/02_normalization.html#removing-single-characters",
    "title": "Normalization & Noise Reduction",
    "section": "13. Removing single characters",
    "text": "13. Removing single characters\nAfter removing digits and handling contractions, some single characters may remain in the text. For example:\n\n\"S1\" (referring to “Season one”) would become \"s\" after digit removal.\nPossessive forms like \"Mark's\" would turn into \"Mark s\" once the apostrophe is removed.\n\nThese isolated single characters generally do not carry meaningful information for analysis, so we should remove them from the dataset to keep our text clean and focused.\nWe will be using the function str_replace_all() comes from the stringr package:\n# Remove single characters (e.g S1 which became S)\nstr_replace_all(single_characters, \"\") %&gt;%",
    "crumbs": [
      "Normalization & Noise Reduction"
    ]
  },
  {
    "objectID": "chapters/1.Preprocessing/02_normalization.html#dealing-with-extraspaces",
    "href": "chapters/1.Preprocessing/02_normalization.html#dealing-with-extraspaces",
    "title": "Normalization & Noise Reduction",
    "section": "12. Dealing with Extraspaces",
    "text": "12. Dealing with Extraspaces\nAfter completing several normalization steps, we should also account for any extra spaces at the beginning or end of the text. These often come from inconsistent user input, copy-pasting, or formatting issues on different platforms. Let’s clean up these spaces before moving on to the next episode.\n# Remove extra whitespaces\nstr_squish()\nPutting every step together we should have the following code:\n#Create a new column for the output clean text\ncomments &lt;- comments %&gt;%\n  mutate(\n    text_cleaned = text %&gt;%\n      # Remove URLs\n      str_replace_all(url_pattern, \"\") %&gt;%\n      # Replace hidden/special characters with space\n      str_replace_all(hidden_characters, \" \") %&gt;%\n      # Standardize apostrophes\n      str_replace_all(apostrophes, \"'\") %&gt;%\n      # Expand contractions (e.g., \"don't\" → \"do not\")\n      replace_contraction() %&gt;%\n      # Remove mentions (@username)\n      str_replace_all(mentions, \"\") %&gt;%\n      # Split camelCase hashtags\n      str_replace_all(hashtag_splitter, \"\\\\1 \\\\2\") %&gt;%\n      # Convert to lowercase\n      str_to_lower() %&gt;%\n      # Remove punctuation\n      str_replace_all(punctuation, \" \") %&gt;%\n      # Remove digits\n      str_replace_all(\"[[:digit:]]+\", \" \") %&gt;%\n      # Normalize repeated characters (e.g., loooove → love)\n      str_replace_all(repeated_chars, \"\\\\1\") %&gt;%\n      # Replace emojis with textual description (function - see above)\n      replace_emojis(emoji_dict) %&gt;%\n      # Remove single characters (e.g S1 which became S)\n      str_replace_all(single_characters, \"\") %&gt;%\n      # Remove extra whitespaces\n      str_squish()\n  )\nNeat! Our normalization and noise reduction code chunk is complete, but don’t forget to close the parentheses before running it! Let’s see and compare the original “text column” compares to “text_cleaned”.",
    "crumbs": [
      "Normalization & Noise Reduction"
    ]
  },
  {
    "objectID": "chapters/1.Preprocessing/02_normalization.html#one-more-thing-before-we-are-done",
    "href": "chapters/1.Preprocessing/02_normalization.html#one-more-thing-before-we-are-done",
    "title": "Normalization & Noise Reduction",
    "section": "One more thing before we are done",
    "text": "One more thing before we are done\nOh, no, if we search for “s1_1755” we will notice that we still have a waffle 🧇 emoji in that comment. Well, not too worry, while this emoji wasn’t included in the original dictionary we used, we can still add it to it for automatic handling:\n{emoji_dict &lt;- emo::jis[, c(\"emoji\", \"name\")]}\nemoji_dict &lt;- emoji_dict %&gt;% add_row(\"emoji\" = \"🧇\", \"name\" = \"waffle\")\nemoji_dict\n\n\n\n\n\n\nTip🦾 Challenge\n\n\n\n\n\nIdentify at least one remaining emoji that wasn’t converted and add it to the emoji dictionary. It is okay if we are focusing on different ones, since the process is the same.\n\nSolution\n# Adding new emojis manually to dictionary \nemoji_dict &lt;- emoji_dict %&gt;% add_row(\"emoji\" = \"🧇\", \"name\" = \"waffle\") %&gt;%\nadd_row(emoji = \"🥹\", name = \"pleading face\")\nemoji_dict\n\n\n\n\nLet’s re-run the code chunk and check how those emojis were taken care of. With normalization and noise reduction completed, we are now ready to move to the next preprocessing step: tokenization.\n\n\n\n\n\n\nNote📑 Suggested Readings\n\n\n\nBai, Q., Dan, Q., Mu, Z., & Yang, M. (2019). A systematic review of emoji: Current research and future perspectives. Frontiers in psychology, 10, https://doi.org/10.3389/fpsyg.2019.02221\nGraham, P. V. (2024). Emojis: An Approach to Interpretation. UC L. SF Commc’n and Ent. J., 46, 123. https://repository.uclawsf.edu/cgi/viewcontent.cgi?article=1850&context=hastings_comm_ent_law_journal",
    "crumbs": [
      "Normalization & Noise Reduction"
    ]
  },
  {
    "objectID": "chapters/1.Preprocessing/04_stopwords.html",
    "href": "chapters/1.Preprocessing/04_stopwords.html",
    "title": "Stop Words Removal",
    "section": "",
    "text": "Stop words are commonly occurring words that are usually filtered out during natural language processing, as they carry minimal semantic weight and are not as useful for feature extraction.\nExamples include articles (i.e., a, an, the), prepositions (e.g., in, on, at), conjunctions (and, but, or), and pronouns (they, she, he), but the list goes on. While they appear often in text, they usually don’t add significant meaning to a sentence or search query.\nBy ignoring stop words, search engines, databases, chatbots and virtual assistants can improve the speed of crawling and indexing and help deliver faster, more efficient results. Similar posistive effects applies to other NLP tasks and models performance, including sentiment analysis.\nFor this workshop, we will be using the package stopwords (more info) which is considered a “on-stop stopping” for R users. For English language, the package relies on the Snowball list. But, before we turn to our worksheet to see how that process looks like and how it will apply to our data, let’s have a little challenge!\n\n\n\n\n\n\nNote🧠 Knowledge Check\n\n\n\nHow many stop words can you spot in each of the following sentences:\n\nThe cat was sitting on the mat near the window.\nShe is going to the store because she needs some milk.\nI will be there in the morning if it doesn’t rain.\nThey have been working on the project for several days.\nAlthough he was tired, he continued to walk until he reached the house.\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n1. The cat was sitting on the mat near the window.\n2. She is going to the store because she needs some milk.\n3. I will be there in the morning, if it does not rain.\n4. They have been working on the project for several days.\n5. Although he was very tired, he continued to walk until he reached the house.\n\n\n\n\n\nNow, let’s return to the worksheet and see how we can put that into practice.\nSMART, Snowbal and Onix are the three lexicons available to handle stopwords through the the tidytext ecossytem. They serve the same purpose, removing common, low-information words, but they differ in origin, size, and linguistic design. For this workshop, we will adopt the Snowball list because its less restrictive nature, which helps preserve context, especially important for NLP tasks such as topic modeling, sentiment analysis, or classification.\nWe will start our stop word removal by calling data(\"stop_words\") to load a built-in dataset from the tidytext package. This should create a dictionary containing 1,149 words as part of the lexicon’s library.\n\nThen, we will apply the expression filter(lexicon == \"snowball\") to select the Snowball source (or lexicon). The double equal sign == it is a comparison operator which checks for equality.\nNext, select(word) line keeps only the column called word, dropping other columns like the source name. This gives you a clean list of Snowball stopwords.\nNext, we will remove stopwords from the tokenized text. The anti_join(..., by = \"word\") function keeps only the words that do not match any word in the Snowball stopword list. The result, stored in nonstopwords, is a dataset containing only the meaningful words from your text, with the common stopwords removed.\nThe code chunk, should look like:\n# Load stop words\ndata(\"stop_words\")\n\n# Filter for Snowball stopwords only (less aggressive than SMART)\nsnowball_stopwords &lt;- stop_words %&gt;%\n  filter(lexicon == \"snowball\") %&gt;%\n  select(word)  # keep only the 'word' column\n\n# Remove stopwords from your tokenized data\nnonstopwords &lt;- tokenized %&gt;%\n  anti_join(snowball_stopwords, by = \"word\")\nAwesome! This step should bring our token count down to 74,264 by removing filler and unnecessary words:\n\nWe are now ready to move to lemmatization.\n\n\n\n\n\n\nNote📑 Suggested Reading\n\n\n\nCheck out this blog post for a summary of the history of stop words, discussion on its applications and some perspectives on developments in the age of AI.\nGaviraj, K. (2025, April 24). The origins of stop words. BytePlus. https://www.byteplus.com/en/topic/400391?title=the-origins-of-stop-words",
    "crumbs": [
      "Stop Words Removal"
    ]
  },
  {
    "objectID": "chapters/1.Preprocessing/06_conclusion.html",
    "href": "chapters/1.Preprocessing/06_conclusion.html",
    "title": "Conclusion",
    "section": "",
    "text": "In this workshop, we navigated the challenges of preprocessing of unustrucutred social media data, highlighting how messy, inconsistent, and noisy real-world datasets can be. One key takeaway is the importance of thoroughly assessing the data in the context of your project goals before diving into processing and be mindful that the order of factors do influence the outcome.\nNot all cleaning or transformation steps are universally beneficial and decisions should be guided by what is meaningful for your analysis or model objectives. Emojis, for example, can convey sentiment, irony, or context that may be essential for analysis, so decisions on whether to remove, convert, or retain them should be goal-driven.\nSimilarly, numbers such as dates, prices, or statistics can carry meaningful information, but they can also introduce noise if misinterpreted or inconsistently formatted. Thoughtful handling of these elements ensures that preprocessing enhances the dataset’s usefulness rather than stripping away valuable signals.\nOverly aggressive text cleaning removes content that is vital to the context, meaning, or nuance of a text and can damage the performance of natural language processing (NLP) models. The specific steps that lead to this problem depend on the end goal of your NLP task. \nWhile preprocessing is considered a key step, if performed incorrectly or poorly planned, it can do more harm than good to the analysis. In short, preprocessing is not merely a mechanical phase in the pipeline but a thoughtful design choice that shapes the quality, interpretability, and trustworthiness of all subsequent tasks.\nBy critically evaluating the data and aligning preprocessing strategies with the end goals, we can ensure that the cleaned dataset not only becomes more manageable but also more valuable for deriving actionable insights. Ultimately, thoughtful data assessment is just as important as the technical preprocessing steps themselves.\n\n\n\n\n\n\nTip🤓 Suggested Readings\n\n\n\nChai CP. Comparison of text preprocessing methods. Natural Language Engineering. 2023;29(3):509-553. https://doi.org/10.1017/S1351324922000213\nSiino, M., Tinnirello, I., & La Cascia, M. (2024). Is text preprocessing still worth the time? A comparative survey on the influence of popular preprocessing methods on Transformers and traditional classifiers. Information Systems, 121, 102342. https://doi.org/10.1016/j.is.2023.102342",
    "crumbs": [
      "Conclusion"
    ]
  }
]