<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Normalization &amp; Noise Reduction – Introduction to Text Analysis in R</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-ae3f271f63f1cd2c76b717a789340001.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../_static/adapt-meds-website-styles.scss">
</head>

<body class="nav-sidebar docked nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Introduction to Text Analysis in R</span>
    </a>
  </div>
        <div class="quarto-navbar-tools tools-end">
    <a href="../../about.html" title="About RDS" class="quarto-navigation-tool px-1" aria-label="About RDS"><i class="bi bi-"></i></a>
    <div class="dropdown">
      <a href="" title="" id="quarto-navigation-tool-dropdown-0" class="quarto-navigation-tool dropdown-toggle px-1" data-bs-toggle="dropdown" aria-expanded="false" role="link" aria-label=""><i class="bi bi-github"></i></a>
      <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="quarto-navigation-tool-dropdown-0">
          <li>
            <a class="dropdown-item quarto-navbar-tools-item" href="https://github.com/UCSB-Library-Research-Data-Services/text-analysis-series" target="_blank">
            Source Code
            </a>
          </li>
          <li>
            <a class="dropdown-item quarto-navbar-tools-item" href="https://github.com/UCSB-Library-Research-Data-Services/text-analysis-series/issues/new?title=Bug%20Report%3A%20%5BDescribe%20the%20issue%20briefly%5D&amp;body=**Description%20of%20the%20issue%3A**%0A%0A**Steps%20to%20reproduce%3A**%0A1.%20%0A2.%20%0A3.%20%0A%0A**Expected%20behavior%3A**%0A%0A**Actual%20behavior%3A**%0A%0A**Additional%20context%3A**" target="_blank">
            Report a Bug
            </a>
          </li>
      </ul>
    </div>
</div>
          <div id="quarto-search" class="" title="Search"></div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../chapters/1.Preprocessing/02_normalization.html">Normalization &amp; Noise Reduction</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
      <a href="../../index.html" class="sidebar-logo-link">
      </a>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Home</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/1.Preprocessing/01_introduction.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Introduction to Text Preprocessing</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/1.Preprocessing/02_normalization.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Normalization &amp; Noise Reduction</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/1.Preprocessing/03_tokenization.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Word Tokenization</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/1.Preprocessing/04_stopwords.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Stop Words Removal</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/1.Preprocessing/05_lemmatization.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Lemmatization</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/1.Preprocessing/06_conclusion.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Conclusion</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../about.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">About RDS</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#why-does-it-matter" id="toc-why-does-it-matter" class="nav-link active" data-scroll-target="#why-does-it-matter">Why does it matter?</a></li>
  <li><a href="#the-role-of-regular-expressions" id="toc-the-role-of-regular-expressions" class="nav-link" data-scroll-target="#the-role-of-regular-expressions">The Role of Regular Expressions</a></li>
  <li><a href="#creating-a-new-data-frame" id="toc-creating-a-new-data-frame" class="nav-link" data-scroll-target="#creating-a-new-data-frame">0. Creating a New Data Frame</a></li>
  <li><a href="#removing-urls" id="toc-removing-urls" class="nav-link" data-scroll-target="#removing-urls">1. Removing URLs</a></li>
  <li><a href="#hidden-characters" id="toc-hidden-characters" class="nav-link" data-scroll-target="#hidden-characters">2. Hidden Characters</a></li>
  <li><a href="#handling-apostrophes" id="toc-handling-apostrophes" class="nav-link" data-scroll-target="#handling-apostrophes">3. Handling Apostrophes</a></li>
  <li><a href="#expanding-contractions" id="toc-expanding-contractions" class="nav-link" data-scroll-target="#expanding-contractions">4. Expanding Contractions</a></li>
  <li><a href="#splitting-hashtags" id="toc-splitting-hashtags" class="nav-link" data-scroll-target="#splitting-hashtags">5. Splitting Hashtags</a></li>
  <li><a href="#converting-to-lowercase" id="toc-converting-to-lowercase" class="nav-link" data-scroll-target="#converting-to-lowercase">6. Converting to Lowercase</a></li>
  <li><a href="#removing-mentions" id="toc-removing-mentions" class="nav-link" data-scroll-target="#removing-mentions">7. Removing Mentions</a></li>
  <li><a href="#cleaning-punctuation-symbols-and-numbers" id="toc-cleaning-punctuation-symbols-and-numbers" class="nav-link" data-scroll-target="#cleaning-punctuation-symbols-and-numbers">8. Cleaning Punctuation, Symbols and Numbers</a></li>
  <li><a href="#handling-elongation" id="toc-handling-elongation" class="nav-link" data-scroll-target="#handling-elongation">9. Handling Elongation</a></li>
  <li><a href="#convert-emojis-to-text" id="toc-convert-emojis-to-text" class="nav-link" data-scroll-target="#convert-emojis-to-text">10. Convert Emojis to Text</a></li>
  <li><a href="#dealing-with-extraspaces" id="toc-dealing-with-extraspaces" class="nav-link" data-scroll-target="#dealing-with-extraspaces">11. Dealing with Extraspaces</a></li>
  <li><a href="#one-more-thing" id="toc-one-more-thing" class="nav-link" data-scroll-target="#one-more-thing">One more thing</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-body" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title">Normalization &amp; Noise Reduction</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
</div>



<div class="quarto-title-meta column-body">

    
  
    
  </div>
  


</header>


<section id="why-does-it-matter" class="level3">
<h3 class="anchored" data-anchor-id="why-does-it-matter">Why does it matter?</h3>
<p>As previously mentioned, in order to perform accurate and reliable analysis, we need to “take out the garbage” first by preprocessing the text to clean, standardize, and structure the input data. These steps help reduce noise and improve the model’s accuracy.</p>
<p>Below we use another analogy to illustrate the impact of noise on data analysis outcomes. Imagine a tree that is slowly dying. On the surface, its leaves may still appear green, but closer inspection reveals branches that are brittle, bark that is cracking, and roots that are struggling to find nourishment. If we only focus on the healthy-looking leaves, we might draw a misleading conclusion about the tree’s overall condition. Similarly, in text analysis, raw data often contains “noise,” such as irrelevant words, inconsistent formatting, or errors, which can obscure meaningful patterns. If we feed this noisy data directly into an analysis, the results can be skewed, incomplete, or misleading, just as judging the tree’s health by its leaves alone would be.</p>
<p>Just as a gardener would prune dead branches, enrich the soil, and care for the roots to revive the tree, data analysts perform preprocessing steps to clean, standardize, and structure the text. By removing noise and focusing on the core content, we give the analysis the best chance to reveal true insights, uncover trends, and support reliable conclusions. In short, the quality of our “data garden” directly determines the health of the insights it produces.</p>
<p><img src="images/noise.png" class="img-fluid"></p>
<p>The main goal of normalization is to remove irrelevant content and standardize the data in order to reduce noise. Below are some key actions we’ll be performing during this workshop:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 18%">
<col style="width: 81%">
</colgroup>
<thead>
<tr class="header">
<th>Action</th>
<th>Why it matters?</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Remove URLs</td>
<td>URLs often contain irrelevant noise and don’t contribute meaningful content for analysis.</td>
</tr>
<tr class="even">
<td>Remove Punctuation &amp; Symbols</td>
<td>Punctuation marks and other symbols including those extensively used in social media for mentioning (@) or tagging (#) rarely adds value in most NLP tasks and can interfere with tokenization (as we will cover in a bit) or word matching.</td>
</tr>
<tr class="odd">
<td>Remove Numbers</td>
<td>Numbers can be noise in most contexts unless specifically relevant (e.g., in financial or medical texts) don’t contribute much to the analysis. However, in NLP tasks they are considered important, there might be considerations to replace them with dummy tokens (e.g.&nbsp;&lt;NUMBER&gt;), or even converting them into their written form (e.g, 100 becomes one hundred).</td>
</tr>
<tr class="even">
<td>Normalize Whitespaces</td>
<td>Ensures consistent word boundaries and avoids issues during tokenization or frequency analysis.</td>
</tr>
<tr class="odd">
<td>Convert to Lowercase</td>
<td>Prevents case sensitivity from splitting word counts due to case variations (e.g., “AppleTV” ≠ “APPLETV” ≠ “appleTV” ≠ “appletv”), improving model consistency.</td>
</tr>
<tr class="even">
<td>Convert Emojis to Text</td>
<td>Emojis play a unique role in text analysis, as they often convey sentiment. Rather than removing them, we will convert them into their corresponding text descriptions.</td>
</tr>
</tbody>
</table>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>🧠 Knowledge Check
</div>
</div>
<div class="callout-body-container callout-body">
<p>In pairs or groups of three, identify the techniques you would consider using to normalize and reduce noise in the following sentence:</p>
<p>“OMG!! 😱 I can’t believe it… This is CRAZY!!! #unreal 🤯”</p>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center collapsed" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Solution
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>How many techniques could you identify? Bingo if you have spotted all four!</p>
<p>After applying them the sentence should look like:</p>
<p><em>omg [face scream in fear] I can not believe it this is crazy unreal [exploding head]</em></p>
</div>
</div>
</div>
</div>
</div>
<p>A caveat when working with emojis is that they are figurative and highly contextual. Also, there may be important generational and cultural variability in how people interpret them. For example, some countries may use the Folded Hands Emoji (🙏) as a sign of thank you where others may seem as religious expression. Also, some may use it in a more positive way as gratitude, hope or respect, or in a negative context, where they might be demonstrating submission or begging.</p>
<p>You might have noticed based on the example above that emojis are converted to their equivalent CLDR (common, human-readable name) based on this <a href="https://www.unicode.org/emoji/charts/full-emoji-list.html">emoji unicode list</a>, which are not as nuanced and always helpful to detect sentiment. While not always perfect, that is an important step to normalize the data and we will see how this process looks like later on this episode.</p>
</section>
<section id="the-role-of-regular-expressions" class="level2">
<h2 class="anchored" data-anchor-id="the-role-of-regular-expressions">The Role of Regular Expressions</h2>
<p>Regular expressions (regex) are powerful tools for pattern matching and text manipulation. They allow you to identify, extract, or replace specific sequences of characters in text, such as email addresses, URLs, hashtags, or user mentions. In text cleaning, regex is essential for reducing noise by removing unwanted elements like punctuation, special symbols, or repeated whitespace, which can interfere with analysis. By systematically filtering out irrelevant or inconsistent text, regex helps create cleaner, more structured data, improving the accuracy of downstream tasks like sentiment analysis, topic modeling, or machine learning. Essentially, regex transforms messy raw text into a manageable, analyzable format.</p>
<p>We won’t have time to cover regular expressions in detail during this workshop, but it’s important to know that they are a fundamental tool for working with text data. Regex allows you to identify, extract, and manipulate patterns in text, such as emails, hashtags, or special characters, which is essential for cleaning and preparing data for analysis. Even though we won’t dive into the syntax or practice exercises here, being aware of regex and its capabilities can help you understand how text preprocessing works behind the scenes and guide you toward resources to learn it on your own.</p>
<p>Working with regular expressions might require some trial and error, especially when you are working with a large and highly messy corpus. To make things easier and make the lesson less typing-intensive, we’ve pre-populated the worksheet with regex patterns noted below and will provide a clear explanation of how they are expected to function, so you can follow along confidently.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>url_pattern <span class="ot">&lt;-</span> <span class="st">"http[s]?://[^</span><span class="sc">\\</span><span class="st">s,]+|www</span><span class="sc">\\</span><span class="st">.[^</span><span class="sc">\\</span><span class="st">s,]+"</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>hidden_characters <span class="ot">&lt;-</span> <span class="st">"[\u00A0\u2066\u2067\u2068\u2069]"</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>apostrophes <span class="ot">&lt;-</span> (<span class="st">"[‘’‛ʼ❛❜＇`´′]"</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>hashtag_splitter <span class="ot">&lt;-</span> <span class="st">"(?&lt;![#@])([a-z])([A-Z])"</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>mentions <span class="ot">&lt;-</span> <span class="st">"@[A-Za-z0-9_]+"</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>punctuation <span class="ot">&lt;-</span> <span class="st">"[[:punct:]“”‘’–—…|+]"</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>numbers <span class="ot">&lt;-</span> <span class="st">"[[:digit:]]"</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>repeated_chars <span class="ot">&lt;-</span> <span class="st">"(.)</span><span class="sc">\\</span><span class="st">1{2,}"</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>Get Help with Regex
</div>
</div>
<div class="callout-body-container callout-body">
<p>Testing regular expressions is essential for accuracy and reliability, since complex patterns often produce unexpected results. Careful testing ensures your regex matches the intended text, rejects invalid inputs, and performs efficiently, while also revealing potential bugs before they impact your system. To make testing more effective, use tools like <a href="https://regex101.com/">Regex101</a> or the <a href="https://coderpad.io/regular-expression-cheat-sheet">Coder Pad cheatsheet</a> or and be sure to check tricky border cases that might otherwise slip through.</p>
</div>
</div>
<div class="callout callout-style-default callout-caution callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Caution</span>The Order Matters!
</div>
</div>
<div class="callout-body-container callout-body">
<p>When performing text normalization and noise reduction, <strong>the order of steps matters</strong> because each transformation changes the text in a way that can affect subsequent steps. Doing things in a different order can lead to different results, and sometimes even incorrect or unexpected outcomes. For example, if we <strong>remove punctuation before expanding contractions</strong>, <code>"can't"</code> might turn into <code>"cant"</code> instead of <code>"cannot"</code>, losing the correct meaning.</p>
</div>
</div>
<p>Alright, let’s return to our worksheet to dive into cleaning and normalization. The order in which we apply these steps matters, each transformation builds on the previous one to make the data more consistent, structured, and analysis-ready. Keep in mind, however, that the pipeline we’ll use here is unlikely to perfectly fit every type of textual data; the best approach always depends on your specific dataset and project goals.</p>
</section>
<section id="creating-a-new-data-frame" class="level2">
<h2 class="anchored" data-anchor-id="creating-a-new-data-frame">0. Creating a New Data Frame</h2>
<p>The first step would be to create a new data frame called <code>comments_clean</code> and adding a <code>clean_text</code> column to it:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>comments_clean <span class="ot">&lt;-</span> comments <span class="sc">%&gt;%</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">clean_text =</span> text <span class="sc">%&gt;%</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Don’t forget the pipe operator `%` since we want to pass the result of this function as an input to the next, as we continue working on the code chunk.</p>
</section>
<section id="removing-urls" class="level2">
<h2 class="anchored" data-anchor-id="removing-urls">1. Removing URLs</h2>
<p>This comes first because URLs can contain other characters (like punctuation or digits) that you’ll handle later, so removing them early prevents interference. Because we have a great variation in format (e.g., http://, https://, or www.) we had to define a regex pattern, where:</p>
<ul>
<li>http[s]?:// → matches “http://” or “https://”</li>
<li>[^\\s,]+ → matches one or more characters that are not spaces or commas (the rest of the URL)</li>
<li>| → OR operator; matches either the left or right pattern</li>
<li>www\.[^\\s,]+ → matches URLs starting with “www.” followed by non-space/non-comma characters</li>
</ul>
<p>Since we already have the URL pattern, we can use <code>str_replace_all()</code> from the <code>stringr</code> package to replace all matching URLs with an empty string in our text.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str_replace_all</span>(url_pattern, <span class="st">""</span>) <span class="sc">%&gt;%</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="hidden-characters" class="level2">
<h2 class="anchored" data-anchor-id="hidden-characters">2. Hidden Characters</h2>
<p>Hidden characters are one of the trickiest challenges in text preprocessing. These are characters that aren’t immediately visible when you view text, but they can interfere with analysis, parsing, or modeling. Hidden characters include things like non-breaking spaces, zero-width spaces, invisible control characters (like carriage returns <code>\r</code>, line feeds <code>\n</code>, tabs <code>\t</code>), Unicode invisible formatting characters, and even special symbols copied from PDFs or web pages.</p>
<p>In practice, these characters can cause subtle errors. For example, they can make two strings appear different even though they look identical, break tokenization, or create issues when matching patterns with regular expressions. In natural language processing (NLP), they can inflate vocabulary size unnecessarily, confuse word embeddings, or lead to inaccurate frequency counts.</p>
<p>To ensure they won’t cause us future problems, we have included a regex pattern that matches certain hidden or invisible Unicode characters in text. Here’s a breakdown:</p>
<ul>
<li><p><code>[]</code> → This denotes a character class in regex, meaning it will match any single character listed inside.</p></li>
<li><p><code>\u00A0</code> → This is a non-breaking space. Unlike a normal space, it doesn’t allow line breaks. It often appears when copying text from websites or PDFs.</p></li>
<li><p><code>\u2066</code>, <code>\u2067</code>, <code>\u2068</code>, <code>\u2069</code> → These are Unicode “isolate” control characters used for bidirectional text handling (like in right-to-left languages). They are invisible and generally unnecessary for text analysis.</p></li>
</ul>
<p>Let’s now call that variable and enter some code to address that:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str_replace_all</span>(hidden_characters, <span class="st">" "</span>) <span class="sc">%&gt;%</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="handling-apostrophes" class="level2">
<h2 class="anchored" data-anchor-id="handling-apostrophes">3. Handling Apostrophes</h2>
<p>This step helps clean up text by making sure all apostrophes are consistent, rather than a mix of fancy Unicode versions. Applying it to the <code>text</code> column in our <code>comments</code> dataset should look like. In this case, the pattern “[’‘ʼ]” looks for several different kinds of apostrophes and backticks; like the left and right single quotes, the modifier apostrophe, and the backtick. Each of those gets replaced with a simple, standard apostrophe (’`) when we apply the function below:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str_replace_all</span>(apostrophes, <span class="st">"'"</span>) <span class="sc">%&gt;%</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Note that once again, we are calling the stored variable with the regex containing different forms of apostrophes, especially from social media, PDFs, or copy-pasted content.</p>
</section>
<section id="expanding-contractions" class="level2">
<h2 class="anchored" data-anchor-id="expanding-contractions">4. Expanding Contractions</h2>
<p>Now that we have normalized variations of apostrophes, we can properly handle contractions. In everyday language, we often shorten words: <em>can’t</em>, <em>don’t</em>, <em>it’s</em>. These make speech and writing flow more easily, but they can cause confusion for Natural Language Processing (NLP) models. Expanding contractions, such as changing <em>can’t</em> to <em>cannot</em> or <em>it’s</em> to <em>it is</em>, helps bring clarity and consistency to the text because NLP models treat <em>don’t</em> and <em>do not</em> as completely different words, even though they mean the same thing. Also, words like <em>cant</em>, <em>doesnt</em>, and <em>whats</em> lose their meaning. Expanding contractions reduces this inconsistency and ensures that both forms are recognized as the same concept. Expanding it to <em>is not happy</em> makes the negative sentiment explicit, which is especially important in tasks like sentiment analysis.</p>
<p>So, while it may seem like a small step, it often leads to cleaner data, leaner models, and more accurate results. First, however, we need to ensure that apostrophes are handled correctly. It’s not uncommon to encounter messy text where nonstandard characters are used in place of the straight apostrophe (’). Such inconsistencies are very common and can disrupt contraction expansion.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 18%">
<col style="width: 18%">
<col style="width: 63%">
</colgroup>
<thead>
<tr class="header">
<th>Character</th>
<th>Unicode</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>'</code></td>
<td>U+0027</td>
<td>Standard straight apostrophe, used in most dictionaries</td>
</tr>
<tr class="even">
<td><code>’</code></td>
<td>U+2019</td>
<td>Right single quotation mark (curly apostrophe)</td>
</tr>
<tr class="odd">
<td><code>‘</code></td>
<td>U+2018</td>
<td>Left single quotation mark</td>
</tr>
<tr class="even">
<td><code>ʼ</code></td>
<td>U+02BC</td>
<td>Modifier letter apostrophe</td>
</tr>
<tr class="odd">
<td><code>`</code></td>
<td>U+0060</td>
<td>Grave accent (sometimes typed by mistake)</td>
</tr>
</tbody>
</table>
<p>Let’s make sure that words like “don’t” become “do not”, by adding the following line to our code chunk:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">replace_contraction</span>() <span class="sc">%&gt;%</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="splitting-hashtags" class="level2">
<h2 class="anchored" data-anchor-id="splitting-hashtags">5. Splitting Hashtags</h2>
<p>Hashtags are a powerful tool in social media and online communication, serving as a way to categorize content, highlight topics, and increase visibility. By prefixing a word or phrase with <code>#</code>, users can link their posts to a broader conversation, making it easier for others to discover and engage with content on that topic. Hashtags also act as a keyword system, allowing researchers and analysts to track trends, measure sentiment, or analyze public discussions around specific themes. In text analysis, properly handling hashtags ensures that the meaningful content within them is captured, improving tokenization, searchability, and overall insights from the data. They effectively turn user-generated text into a structured source of topical information that can be leveraged for both social and analytical purposes.</p>
<p>Hashtags are often written as one long string with no spaces, e.g., <code>#SeveranceIsFire</code>. Splitting them into separate words not only makes it human-readable and easier to understand, but also ensure meaningful tokes and improves text analysis accuracy.</p>
<p>While some researchers might want to separate them from the text for further analysis, we can also split concatenated words in hashtags or camelCase text by inserting a space between them. In our regex pattern hashtag_splitter, we have:</p>
<ul>
<li><p><code>(?&lt;![#@])</code>: negative lookbehind to avoid splitting right after <code>#</code> or <code>@</code>, preserving hashtags and mentions.</p></li>
<li><p><code>([a-z])([A-Z])</code>: captures lowercase followed by uppercase letters, identifying camelCase word boundaries.</p></li>
</ul>
<p>We can call that pattern and use the string replacement function to adds the space between words while keeping the letters themselves intact, by adding the following to our code chunk:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str_replace_all</span>(hashtag_splitter, <span class="st">"</span><span class="sc">\\</span><span class="st">1 </span><span class="sc">\\</span><span class="st">2"</span>) <span class="sc">%&gt;%</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>In simple terms, the <code>"\1 \2"</code> inserts the first captured piece, adds a space, and then inserts the second captured piece.</p>
<p>You might be asking, “wait a minute but what about the hastag (#) itself?”. It is a valid question, but not to worry, we will take care of that later when handling symbols.</p>
</section>
<section id="converting-to-lowercase" class="level2">
<h2 class="anchored" data-anchor-id="converting-to-lowercase">6. Converting to Lowercase</h2>
<p>Having all text converted to lowercase will be our next step, by adding the following line to our code chunk:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str_to_lower</span>() <span class="sc">%&gt;%</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="removing-mentions" class="level2">
<h2 class="anchored" data-anchor-id="removing-mentions">7. Removing Mentions</h2>
<p>Continuing with our workflow, we will now handle direct mentions and usernames in our dataset, as they do not contribute relevant information to our analysis. We will use a function to replace all occurrences of usernames preceded. Since we have pre-populated the regular expression and stored it in the variable “mentions”, <code>mentions &lt;- "@[A-Za-z0-9_]+"</code> we will only need to add that we want to replace it with an empty string and remove them.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str_replace_all</span>(mentions, <span class="st">""</span>) <span class="sc">%&gt;%</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="cleaning-punctuation-symbols-and-numbers" class="level2">
<h2 class="anchored" data-anchor-id="cleaning-punctuation-symbols-and-numbers">8. Cleaning Punctuation, Symbols and Numbers</h2>
<p>Alright, time to remove punctuation and symbols, and then numbers.</p>
<p>But first, last break it down, the punctuation regex pattern, where <strong><code>[[:punct:]]</code></strong> is character class in regex that matches any standard punctuation character, including: ! ” # $ % &amp; ’ ( ) * + , - . / : ; &lt; = &gt; ? @ [ &nbsp;] ^ _ ` { | } ~. To be safe and because our dataset is really messy, we added extra characters (<code>“”‘’–—…|+</code>) to catch some special quotes, dashes, ellipsis, and symbols that <code>[[:punct:]]</code> might miss. Calling that variable, we can remove them by adding to our code:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str_replace_all</span>(punctuation, <span class="st">" "</span>) <span class="sc">%&gt;%</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Next, last clear some numbers by adding <code>[[:digit:]]+</code>. This is the regex pattern matches any single digit (0–9) and <code>+</code> means one or more digits in a row. So it matches sequences like <code>7</code>, <code>42</code>, <code>2025</code>, etc:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str_replace_all</span>(<span class="st">"[[:digit:]]+"</span>, <span class="st">" "</span>) <span class="sc">%&gt;%</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="handling-elongation" class="level2">
<h2 class="anchored" data-anchor-id="handling-elongation">9. Handling Elongation</h2>
<p>In user-generated content, it’s common to see repeated letters used for emphasis (e.g., “Amaaaazing,” “Loooove”). For that, we have the regex pattern <code>repeated_chars &lt;- "(.)\1{2,}"</code>, where:</p>
<ul>
<li><p><code>(.)</code>: captures group that matches any single character (except line breaks, depending on regex flavor). The <code>.</code> is a wildcard. The parentheses <code>()</code> capture whatever character matched for later reference.</p></li>
<li><p><code>\\1</code>: refers to “whatever was matched by the first capturing group.” In other words, it matches the same character again.</p></li>
<li><p><code>{2,}</code>: means “repeat the previous element at least 2 times.”</p></li>
</ul>
<p>Putting it together <code>(.)\\1{2,}</code> matches any character that repeats 3 or more times consecutively. Why 3? Because the first occurrence is matched by <code>(.)</code> and <code>{2,}</code> requires at least 2 more repetitions, so total = 3+.</p>
<p>Because the pattern is already in our workbook, we can simply add:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str_replace_all</span>(repeated_chars, <span class="st">"\1"</span>) <span class="sc">%&gt;%</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Can you guess what <code>"\1"</code> does? It uses the character we captured earlier, keeping it in the text.</p>
</section>
<section id="convert-emojis-to-text" class="level2">
<h2 class="anchored" data-anchor-id="convert-emojis-to-text">10. Convert Emojis to Text</h2>
<p>Okay, now we’ll convert emojis into their text descriptions to make them machine-readable, using the emoji package to help with this step:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Load the emoji dictionary</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>emoji_dict <span class="ot">&lt;-</span> emo<span class="sc">::</span>jis[, <span class="fu">c</span>(<span class="st">"emoji"</span>, <span class="st">"name"</span>)]</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>emoji_dict</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Take a look at the emoji dictionary we loaded into our RStudio environment. It’s packed with more emojis and some surprising meanings than you might expect. We will then write a separate function to deal with those emojis:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Function to replace emojis in text with their corresponding names</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>replace_emojis <span class="ot">&lt;-</span> <span class="cf">function</span>(text, emoji_dict) {</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">stri_replace_all_fixed</span>(</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">str =</span> text,                  <span class="co"># The text to process</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">pattern =</span> emoji_dict<span class="sc">$</span>emoji,  <span class="co"># The emojis to find</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">replacement =</span> <span class="fu">paste0</span>(emoji_dict<span class="sc">$</span>name, <span class="st">" "</span>), <span class="co"># Their corresponding names</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">vectorize_all =</span> <span class="cn">FALSE</span>        <span class="co"># element-wise replacement in a same string</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Wait, we are not done yet! We still have to add the <code>replace_emojis</code> function, based on our loaded dictionary, into our code chunk. This will replace the emojis with their corresponding text on our dataset:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">replace_emojis</span>(emoji_dict) <span class="sc">%&gt;%</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>[FIXME ADD IMAGES]</p>
<p>Neat! Let’s re-run the code chunk and check it once again. With emojis taken care of, we can now apply the next and final normalization and noise reduction step.</p>
</section>
<section id="dealing-with-extraspaces" class="level2">
<h2 class="anchored" data-anchor-id="dealing-with-extraspaces">11. Dealing with Extraspaces</h2>
<p>After completing several normalization steps, we should also account for any extra spaces at the beginning or end of the text. These often come from inconsistent user input, copy-pasting, or formatting issues on different platforms. Let’s clean up these spaces before moving on to the next episode.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str_squish</span>()<span class="er">)</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Putting every step together we should have the following code:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Create a new column for the output clean text</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>comments <span class="ot">&lt;-</span> comments <span class="sc">%&gt;%</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">text_cleaned =</span> text <span class="sc">%&gt;%</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Remove URLs first</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>      <span class="fu">str_replace_all</span>(url_pattern, <span class="st">""</span>) <span class="sc">%&gt;%</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Replace hidden/special characters with space</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>      <span class="fu">str_replace_all</span>(hidden_characters, <span class="st">" "</span>) <span class="sc">%&gt;%</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Standardize apostrophes</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>      <span class="fu">str_replace_all</span>(apostrophes, <span class="st">"'"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Expand contractions (e.g., "don't" → "do not")</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>      <span class="fu">replace_contraction</span>() <span class="sc">%&gt;%</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Split camelCase hashtags (optional)</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>      <span class="fu">str_replace_all</span>(hashtag_splitter, <span class="st">"</span><span class="sc">\\</span><span class="st">1 </span><span class="sc">\\</span><span class="st">2"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Convert to lowercase</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>      <span class="fu">str_to_lower</span>() <span class="sc">%&gt;%</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Remove mentions (@username)</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>      <span class="fu">str_replace_all</span>(mentions, <span class="st">""</span>) <span class="sc">%&gt;%</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Remove punctuation</span></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>      <span class="fu">str_replace_all</span>(punctuation, <span class="st">" "</span>) <span class="sc">%&gt;%</span></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Remove digits</span></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>      <span class="fu">str_replace_all</span>(<span class="st">"[[:digit:]]+"</span>, <span class="st">" "</span>) <span class="sc">%&gt;%</span></span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Normalize repeated characters (e.g., loooove → love)</span></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a>      <span class="fu">str_replace_all</span>(repeated_chars, <span class="st">"</span><span class="sc">\\</span><span class="st">1"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Replace emojis with textual description (function - see above)</span></span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a>      <span class="fu">replace_emojis</span>(emoji_dict) <span class="sc">%&gt;%</span></span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Remove extra whitespaces</span></span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a>      <span class="fu">str_squish</span>()</span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a>  )</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Neat! Our normalization and noise reduction code chunk is complete, but don’t forget to close the parentheses before running it! Let’s see and compare the original “text column” compares to “text_cleaned”.</p>
</section>
<section id="one-more-thing" class="level2">
<h2 class="anchored" data-anchor-id="one-more-thing">One more thing</h2>
<p>Oh, no, if we look at row 1756 we will notice that we still have a waffle 🧇 emoji in that comment. Well, not too worry, while this emoji wasn’t included in the original dictionary we used, we can still add it to it for automatic handling:</p>
<pre class="{emoji_dict <- emo::jis[, c(&quot;emoji&quot;, &quot;name&quot;)]}"><code>emoji_dict &lt;- emoji_dict %&gt;% add_row("emoji" = "🧇", "name" = "waffle")
emoji_dict</code></pre>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>🦾 Challenge (FIXME)
</div>
</div>
<div class="callout-body-container callout-body">
<p>Identify any remaining emoji that wasn’t converted and add it to the emoji dictionary.</p>
<p>add_row(emoji = “🥹”, name = “pleading face”</p>
</div>
</div>
<p>Let’s re-run the code chunk and check how those emojis were taken care of. With normalization and noise reduction completed, we are now ready to move to the next preprocessing step: tokenization.</p>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>📑 Suggested Readings
</div>
</div>
<div class="callout-body-container callout-body">
<p>Bai, Q., Dan, Q., Mu, Z., &amp; Yang, M. (2019). A systematic review of emoji: Current research and future perspectives. <em>Frontiers in psychology</em>, <em>10</em>, <a href="https://doi.org/10.3389/fpsyg.2019.02221" class="uri">https://doi.org/10.3389/fpsyg.2019.02221</a></p>
<p>Graham, P. V. (2024). Emojis: An Approach to Interpretation. <em>UC L. SF Commc’n and Ent. J.</em>, <em>46</em>, 123. <a href="https://repository.uclawsf.edu/cgi/viewcontent.cgi?article=1850&amp;context=hastings_comm_ent_law_journal" class="uri">https://repository.uclawsf.edu/cgi/viewcontent.cgi?article=1850&amp;context=hastings_comm_ent_law_journal</a></p>
</div>
</div>


<!-- -->

</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
    const viewSource = window.document.getElementById('quarto-view-source') ||
                       window.document.getElementById('quarto-code-tools-source');
    if (viewSource) {
      const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
      viewSource.addEventListener("click", function(e) {
        if (sourceUrl) {
          // rstudio viewer pane
          if (/\bcapabilities=\b/.test(window.location)) {
            window.open(sourceUrl);
          } else {
            window.location.href = sourceUrl;
          }
        } else {
          const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
          modal.show();
        }
        return false;
      });
    }
    function toggleCodeHandler(show) {
      return function(e) {
        const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
        for (let i=0; i<detailsSrc.length; i++) {
          const details = detailsSrc[i].parentElement;
          if (show) {
            details.open = true;
          } else {
            details.removeAttribute("open");
          }
        }
        const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
        const fromCls = show ? "hidden" : "unhidden";
        const toCls = show ? "unhidden" : "hidden";
        for (let i=0; i<cellCodeDivs.length; i++) {
          const codeDiv = cellCodeDivs[i];
          if (codeDiv.classList.contains(fromCls)) {
            codeDiv.classList.remove(fromCls);
            codeDiv.classList.add(toCls);
          } 
        }
        return false;
      }
    }
    const hideAllCode = window.document.getElementById("quarto-hide-all-code");
    if (hideAllCode) {
      hideAllCode.addEventListener("click", toggleCodeHandler(false));
    }
    const showAllCode = window.document.getElementById("quarto-show-all-code");
    if (showAllCode) {
      showAllCode.addEventListener("click", toggleCodeHandler(true));
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb19" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "Normalization &amp; Noise Reduction"</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="an">editor:</span><span class="co"> visual</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="fu">### Why does it matter?</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>As previously mentioned, in order to perform accurate and reliable analysis, we need to "take out the garbage" first by preprocessing the text to clean, standardize, and structure the input data. These steps help reduce noise and improve the model's accuracy.</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>Below we use another analogy to illustrate the impact of noise on data analysis outcomes. Imagine a tree that is slowly dying. On the surface, its leaves may still appear green, but closer inspection reveals branches that are brittle, bark that is cracking, and roots that are struggling to find nourishment. If we only focus on the healthy-looking leaves, we might draw a misleading conclusion about the tree’s overall condition. Similarly, in text analysis, raw data often contains “noise,” such as irrelevant words, inconsistent formatting, or errors, which can obscure meaningful patterns. If we feed this noisy data directly into an analysis, the results can be skewed, incomplete, or misleading, just as judging the tree’s health by its leaves alone would be.</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>Just as a gardener would prune dead branches, enrich the soil, and care for the roots to revive the tree, data analysts perform preprocessing steps to clean, standardize, and structure the text. By removing noise and focusing on the core content, we give the analysis the best chance to reveal true insights, uncover trends, and support reliable conclusions. In short, the quality of our “data garden” directly determines the health of the insights it produces.</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a><span class="al">![](images/noise.png)</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>The main goal of normalization is to remove irrelevant content and standardize the data in order to reduce noise. Below are some key actions we’ll be performing during this workshop:</span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> Action <span class="pp">|</span> Why it matters? <span class="pp">|</span></span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a><span class="pp">|-------------|-----------------------------------------------------------|</span></span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> Remove URLs <span class="pp">|</span> URLs often contain irrelevant noise and don't contribute meaningful content for analysis. <span class="pp">|</span></span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> Remove Punctuation &amp; Symbols <span class="pp">|</span> Punctuation marks and other symbols including those extensively used in social media for mentioning (\@) or tagging (#) rarely adds value in most NLP tasks and can interfere with tokenization (as we will cover in a bit) or word matching. <span class="pp">|</span></span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> Remove Numbers <span class="pp">|</span> Numbers can be noise in most contexts unless specifically relevant (e.g., in financial or medical texts) don't contribute much to the analysis. However, in NLP tasks they are considered important, there might be considerations to replace them with dummy tokens (e.g. <span class="sc">\&lt;</span>NUMBER<span class="sc">\&gt;</span>), or even converting them into their written form (e.g, 100 becomes one hundred). <span class="pp">|</span></span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> Normalize Whitespaces <span class="pp">|</span> Ensures consistent word boundaries and avoids issues during tokenization or frequency analysis. <span class="pp">|</span></span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> Convert to Lowercase <span class="pp">|</span> Prevents case sensitivity from splitting word counts due to case variations (e.g., “AppleTV” ≠ "APPLETV" ≠ “appleTV” ≠ “appletv”), improving model consistency. <span class="pp">|</span></span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> Convert Emojis to Text <span class="pp">|</span> Emojis play a unique role in text analysis, as they often convey sentiment. Rather than removing them, we will convert them into their corresponding text descriptions. <span class="pp">|</span></span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a>:::: {.callout-note icon="false"}</span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true" tabindex="-1"></a><span class="fu">## 🧠 Knowledge Check</span></span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-30"><a href="#cb19-30" aria-hidden="true" tabindex="-1"></a>In pairs or groups of three, identify the techniques you would consider using to normalize and reduce noise in the following sentence:</span>
<span id="cb19-31"><a href="#cb19-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-32"><a href="#cb19-32" aria-hidden="true" tabindex="-1"></a>"OMG!! 😱 I can't believe it... This is CRAZY!!! #unreal 🤯"</span>
<span id="cb19-33"><a href="#cb19-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-34"><a href="#cb19-34" aria-hidden="true" tabindex="-1"></a>::: {.callout-note icon="false" collapse="true"}</span>
<span id="cb19-35"><a href="#cb19-35" aria-hidden="true" tabindex="-1"></a><span class="fu">## Solution</span></span>
<span id="cb19-36"><a href="#cb19-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-37"><a href="#cb19-37" aria-hidden="true" tabindex="-1"></a>How many techniques could you identify? Bingo if you have spotted all four!</span>
<span id="cb19-38"><a href="#cb19-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-39"><a href="#cb19-39" aria-hidden="true" tabindex="-1"></a>After applying them the sentence should look like:</span>
<span id="cb19-40"><a href="#cb19-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-41"><a href="#cb19-41" aria-hidden="true" tabindex="-1"></a>*omg \[face scream in fear\] I can not believe it this is crazy unreal \[exploding head\]*</span>
<span id="cb19-42"><a href="#cb19-42" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb19-43"><a href="#cb19-43" aria-hidden="true" tabindex="-1"></a>::::</span>
<span id="cb19-44"><a href="#cb19-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-45"><a href="#cb19-45" aria-hidden="true" tabindex="-1"></a>A caveat when working with emojis is that they are figurative and highly contextual. Also, there may be important generational and cultural variability in how people interpret them. For example, some countries may use the Folded Hands Emoji (🙏) as a sign of thank you where others may seem as religious expression. Also, some may use it in a more positive way as gratitude, hope or respect, or in a negative context, where they might be demonstrating submission or begging.</span>
<span id="cb19-46"><a href="#cb19-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-47"><a href="#cb19-47" aria-hidden="true" tabindex="-1"></a>You might have noticed based on the example above that emojis are converted to their equivalent CLDR (common, human-readable name) based on this <span class="co">[</span><span class="ot">emoji unicode list</span><span class="co">](https://www.unicode.org/emoji/charts/full-emoji-list.html)</span>, which are not as nuanced and always helpful to detect sentiment. While not always perfect, that is an important step to normalize the data and we will see how this process looks like later on this episode.</span>
<span id="cb19-48"><a href="#cb19-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-49"><a href="#cb19-49" aria-hidden="true" tabindex="-1"></a><span class="fu">## The Role of Regular Expressions</span></span>
<span id="cb19-50"><a href="#cb19-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-51"><a href="#cb19-51" aria-hidden="true" tabindex="-1"></a>Regular expressions (regex) are powerful tools for pattern matching and text manipulation. They allow you to identify, extract, or replace specific sequences of characters in text, such as email addresses, URLs, hashtags, or user mentions. In text cleaning, regex is essential for reducing noise by removing unwanted elements like punctuation, special symbols, or repeated whitespace, which can interfere with analysis. By systematically filtering out irrelevant or inconsistent text, regex helps create cleaner, more structured data, improving the accuracy of downstream tasks like sentiment analysis, topic modeling, or machine learning. Essentially, regex transforms messy raw text into a manageable, analyzable format.</span>
<span id="cb19-52"><a href="#cb19-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-53"><a href="#cb19-53" aria-hidden="true" tabindex="-1"></a>We won’t have time to cover regular expressions in detail during this workshop, but it’s important to know that they are a fundamental tool for working with text data. Regex allows you to identify, extract, and manipulate patterns in text, such as emails, hashtags, or special characters, which is essential for cleaning and preparing data for analysis. Even though we won’t dive into the syntax or practice exercises here, being aware of regex and its capabilities can help you understand how text preprocessing works behind the scenes and guide you toward resources to learn it on your own.</span>
<span id="cb19-54"><a href="#cb19-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-55"><a href="#cb19-55" aria-hidden="true" tabindex="-1"></a>Working with regular expressions might require some trial and error, especially when you are working with a large and highly messy corpus. To make things easier and make the lesson less typing-intensive, we’ve pre-populated the worksheet with regex patterns noted below and will provide a clear explanation of how they are expected to function, so you can follow along confidently.</span>
<span id="cb19-56"><a href="#cb19-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-57"><a href="#cb19-57" aria-hidden="true" tabindex="-1"></a><span class="in">``` r</span></span>
<span id="cb19-58"><a href="#cb19-58" aria-hidden="true" tabindex="-1"></a>url_pattern <span class="ot">&lt;-</span> <span class="st">"http[s]?://[^</span><span class="sc">\\</span><span class="st">s,]+|www</span><span class="sc">\\</span><span class="st">.[^</span><span class="sc">\\</span><span class="st">s,]+"</span></span>
<span id="cb19-59"><a href="#cb19-59" aria-hidden="true" tabindex="-1"></a>hidden_characters <span class="ot">&lt;-</span> <span class="st">"[\u00A0\u2066\u2067\u2068\u2069]"</span></span>
<span id="cb19-60"><a href="#cb19-60" aria-hidden="true" tabindex="-1"></a>apostrophes <span class="ot">&lt;-</span> (<span class="st">"[‘’‛ʼ❛❜＇`´′]"</span>)</span>
<span id="cb19-61"><a href="#cb19-61" aria-hidden="true" tabindex="-1"></a>hashtag_splitter <span class="ot">&lt;-</span> <span class="st">"(?&lt;![#@])([a-z])([A-Z])"</span></span>
<span id="cb19-62"><a href="#cb19-62" aria-hidden="true" tabindex="-1"></a>mentions <span class="ot">&lt;-</span> <span class="st">"@[A-Za-z0-9_]+"</span></span>
<span id="cb19-63"><a href="#cb19-63" aria-hidden="true" tabindex="-1"></a>punctuation <span class="ot">&lt;-</span> <span class="st">"[[:punct:]“”‘’–—…|+]"</span></span>
<span id="cb19-64"><a href="#cb19-64" aria-hidden="true" tabindex="-1"></a>numbers <span class="ot">&lt;-</span> <span class="st">"[[:digit:]]"</span></span>
<span id="cb19-65"><a href="#cb19-65" aria-hidden="true" tabindex="-1"></a>repeated_chars <span class="ot">&lt;-</span> <span class="st">"(.)</span><span class="sc">\\</span><span class="st">1{2,}"</span></span>
<span id="cb19-66"><a href="#cb19-66" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-67"><a href="#cb19-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-68"><a href="#cb19-68" aria-hidden="true" tabindex="-1"></a>::: callout-tip</span>
<span id="cb19-69"><a href="#cb19-69" aria-hidden="true" tabindex="-1"></a><span class="fu">## Get Help with Regex</span></span>
<span id="cb19-70"><a href="#cb19-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-71"><a href="#cb19-71" aria-hidden="true" tabindex="-1"></a>Testing regular expressions is essential for accuracy and reliability, since complex patterns often produce unexpected results. Careful testing ensures your regex matches the intended text, rejects invalid inputs, and performs efficiently, while also revealing potential bugs before they impact your system. To make testing more effective, use tools like <span class="co">[</span><span class="ot">Regex101</span><span class="co">](https://regex101.com/)</span> or the <span class="co">[</span><span class="ot">Coder Pad cheatsheet</span><span class="co">](https://coderpad.io/regular-expression-cheat-sheet)</span> or and be sure to check tricky border cases that might otherwise slip through.</span>
<span id="cb19-72"><a href="#cb19-72" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb19-73"><a href="#cb19-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-74"><a href="#cb19-74" aria-hidden="true" tabindex="-1"></a>::: callout-caution</span>
<span id="cb19-75"><a href="#cb19-75" aria-hidden="true" tabindex="-1"></a><span class="fu">## The Order Matters!</span></span>
<span id="cb19-76"><a href="#cb19-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-77"><a href="#cb19-77" aria-hidden="true" tabindex="-1"></a>When performing text normalization and noise reduction, **the order of steps matters** because each transformation changes the text in a way that can affect subsequent steps. Doing things in a different order can lead to different results, and sometimes even incorrect or unexpected outcomes. For example, if we **remove punctuation before expanding contractions**, <span class="in">`"can't"`</span> might turn into <span class="in">`"cant"`</span> instead of <span class="in">`"cannot"`</span>, losing the correct meaning.</span>
<span id="cb19-78"><a href="#cb19-78" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb19-79"><a href="#cb19-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-80"><a href="#cb19-80" aria-hidden="true" tabindex="-1"></a>Alright, let's return to our worksheet to dive into cleaning and normalization. The order in which we apply these steps matters, each transformation builds on the previous one to make the data more consistent, structured, and analysis-ready. Keep in mind, however, that the pipeline we’ll use here is unlikely to perfectly fit every type of textual data; the best approach always depends on your specific dataset and project goals.</span>
<span id="cb19-81"><a href="#cb19-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-82"><a href="#cb19-82" aria-hidden="true" tabindex="-1"></a><span class="fu">## 0. Creating a New Data Frame</span></span>
<span id="cb19-83"><a href="#cb19-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-84"><a href="#cb19-84" aria-hidden="true" tabindex="-1"></a>The first step would be to create a new data frame called <span class="in">`comments_clean`</span> and adding a <span class="in">`clean_text`</span> column to it:</span>
<span id="cb19-85"><a href="#cb19-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-86"><a href="#cb19-86" aria-hidden="true" tabindex="-1"></a><span class="in">``` r</span></span>
<span id="cb19-87"><a href="#cb19-87" aria-hidden="true" tabindex="-1"></a>comments_clean <span class="ot">&lt;-</span> comments <span class="sc">%&gt;%</span></span>
<span id="cb19-88"><a href="#cb19-88" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(</span>
<span id="cb19-89"><a href="#cb19-89" aria-hidden="true" tabindex="-1"></a>    <span class="at">clean_text =</span> text <span class="sc">%&gt;%</span></span>
<span id="cb19-90"><a href="#cb19-90" aria-hidden="true" tabindex="-1"></a><span class="st">```</span></span>
<span id="cb19-91"><a href="#cb19-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-92"><a href="#cb19-92" aria-hidden="true" tabindex="-1"></a><span class="at">Don't forget the pipe operator \</span><span class="st">`</span>%\<span class="st">`</span><span class="at"> since we want to pass the result of this function as an input to the next, as we continue working on the code chunk.</span></span>
<span id="cb19-93"><a href="#cb19-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-94"><a href="#cb19-94" aria-hidden="true" tabindex="-1"></a><span class="at">## 1. Removing URLs</span></span>
<span id="cb19-95"><a href="#cb19-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-96"><a href="#cb19-96" aria-hidden="true" tabindex="-1"></a><span class="at">This comes first because URLs can contain other characters (like punctuation or digits) that you’ll handle later, so removing them early prevents interference. Because we have a great variation in format (e.g., http://, https://, or www.) we had to define a regex pattern, where:</span></span>
<span id="cb19-97"><a href="#cb19-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-98"><a href="#cb19-98" aria-hidden="true" tabindex="-1"></a><span class="at">-   http\[s\]?:// → matches "http://" or "https://"</span></span>
<span id="cb19-99"><a href="#cb19-99" aria-hidden="true" tabindex="-1"></a><span class="at">-   \[\^</span><span class="sc">\\\\</span><span class="at">s,\]+ → matches one or more characters that are not spaces or commas (the rest of the URL)</span></span>
<span id="cb19-100"><a href="#cb19-100" aria-hidden="true" tabindex="-1"></a><span class="at">-   \| → OR operator; matches either the left or right pattern</span></span>
<span id="cb19-101"><a href="#cb19-101" aria-hidden="true" tabindex="-1"></a><span class="at">-   www</span><span class="sc">\\</span><span class="at">.\[\^</span><span class="sc">\\\\</span><span class="at">s,\]+ → matches URLs starting with "www." followed by non-space/non-comma characters</span></span>
<span id="cb19-102"><a href="#cb19-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-103"><a href="#cb19-103" aria-hidden="true" tabindex="-1"></a><span class="at">Since we already have the URL pattern, we can use </span><span class="st">`</span><span class="fu">str_replace_all</span>()<span class="st">`</span><span class="at"> from the </span><span class="st">`</span>stringr<span class="st">`</span><span class="at"> package to replace all matching URLs with an empty string in our text.</span></span>
<span id="cb19-104"><a href="#cb19-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-105"><a href="#cb19-105" aria-hidden="true" tabindex="-1"></a><span class="st">```</span> r</span>
<span id="cb19-106"><a href="#cb19-106" aria-hidden="true" tabindex="-1"></a><span class="fu">str_replace_all</span>(url_pattern, <span class="st">""</span>) <span class="sc">%&gt;%</span></span>
<span id="cb19-107"><a href="#cb19-107" aria-hidden="true" tabindex="-1"></a><span class="st">```</span></span>
<span id="cb19-108"><a href="#cb19-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-109"><a href="#cb19-109" aria-hidden="true" tabindex="-1"></a><span class="at">## 2. Hidden Characters</span></span>
<span id="cb19-110"><a href="#cb19-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-111"><a href="#cb19-111" aria-hidden="true" tabindex="-1"></a><span class="at">Hidden characters are one of the trickiest challenges in text preprocessing. These are characters that aren’t immediately visible when you view text, but they can interfere with analysis, parsing, or modeling. Hidden characters include things like non-breaking spaces, zero-width spaces, invisible control characters (like carriage returns </span><span class="st">`</span>\r<span class="st">`</span><span class="at">, line feeds </span><span class="st">`</span>\n<span class="st">`</span><span class="at">, tabs </span><span class="st">`</span>\t<span class="st">`</span><span class="at">), Unicode invisible formatting characters, and even special symbols copied from PDFs or web pages.</span></span>
<span id="cb19-112"><a href="#cb19-112" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-113"><a href="#cb19-113" aria-hidden="true" tabindex="-1"></a><span class="at">In practice, these characters can cause subtle errors. For example, they can make two strings appear different even though they look identical, break tokenization, or create issues when matching patterns with regular expressions. In natural language processing (NLP), they can inflate vocabulary size unnecessarily, confuse word embeddings, or lead to inaccurate frequency counts.</span></span>
<span id="cb19-114"><a href="#cb19-114" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-115"><a href="#cb19-115" aria-hidden="true" tabindex="-1"></a><span class="at">To ensure they won't cause us future problems, we have included a regex pattern that matches certain hidden or invisible Unicode characters in text. Here’s a breakdown:</span></span>
<span id="cb19-116"><a href="#cb19-116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-117"><a href="#cb19-117" aria-hidden="true" tabindex="-1"></a><span class="at">-   </span><span class="st">`</span>[]<span class="st">`</span><span class="at"> → This denotes a character class in regex, meaning it will match any single character listed inside.</span></span>
<span id="cb19-118"><a href="#cb19-118" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-119"><a href="#cb19-119" aria-hidden="true" tabindex="-1"></a><span class="at">-   </span><span class="st">`</span>\u00A0<span class="st">`</span><span class="at"> → This is a non-breaking space. Unlike a normal space, it doesn’t allow line breaks. It often appears when copying text from websites or PDFs.</span></span>
<span id="cb19-120"><a href="#cb19-120" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-121"><a href="#cb19-121" aria-hidden="true" tabindex="-1"></a><span class="at">-   </span><span class="st">`</span>\u2066<span class="st">`</span><span class="at">, </span><span class="st">`</span>\u2067<span class="st">`</span><span class="at">, </span><span class="st">`</span>\u2068<span class="st">`</span><span class="at">, </span><span class="st">`</span>\u2069<span class="st">`</span><span class="at"> → These are Unicode “isolate” control characters used for bidirectional text handling (like in right-to-left languages). They are invisible and generally unnecessary for text analysis.</span></span>
<span id="cb19-122"><a href="#cb19-122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-123"><a href="#cb19-123" aria-hidden="true" tabindex="-1"></a><span class="at">Let's now call that variable and enter some code to address that:</span></span>
<span id="cb19-124"><a href="#cb19-124" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-125"><a href="#cb19-125" aria-hidden="true" tabindex="-1"></a><span class="st">```</span> r</span>
<span id="cb19-126"><a href="#cb19-126" aria-hidden="true" tabindex="-1"></a><span class="fu">str_replace_all</span>(hidden_characters, <span class="st">" "</span>) <span class="sc">%&gt;%</span></span>
<span id="cb19-127"><a href="#cb19-127" aria-hidden="true" tabindex="-1"></a><span class="st">```</span></span>
<span id="cb19-128"><a href="#cb19-128" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-129"><a href="#cb19-129" aria-hidden="true" tabindex="-1"></a><span class="at">## 3. Handling Apostrophes</span></span>
<span id="cb19-130"><a href="#cb19-130" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-131"><a href="#cb19-131" aria-hidden="true" tabindex="-1"></a><span class="at">This step helps clean up text by making sure all apostrophes are consistent, rather than a mix of fancy Unicode versions. Applying it to the </span><span class="st">`</span>text<span class="st">`</span><span class="at"> column in our </span><span class="st">`</span>comments<span class="st">`</span><span class="at"> dataset should look like. In this case, the pattern "\[’‘ʼ\]" looks for several different kinds of apostrophes and backticks; like the left and right single quotes, the modifier apostrophe, and the backtick. Each of those gets replaced with a simple, standard apostrophe ('\</span><span class="st">`</span>) when we apply the <span class="cf">function</span> below<span class="sc">:</span></span>
<span id="cb19-132"><a href="#cb19-132" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-133"><a href="#cb19-133" aria-hidden="true" tabindex="-1"></a><span class="st">```</span><span class="at"> r</span></span>
<span id="cb19-134"><a href="#cb19-134" aria-hidden="true" tabindex="-1"></a><span class="at">str_replace_all(apostrophes, "'") %&gt;%</span></span>
<span id="cb19-135"><a href="#cb19-135" aria-hidden="true" tabindex="-1"></a><span class="st">```</span></span>
<span id="cb19-136"><a href="#cb19-136" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-137"><a href="#cb19-137" aria-hidden="true" tabindex="-1"></a>Note that once again, we are calling the stored variable with the regex containing different forms of apostrophes, especially from social media, PDFs, or copy<span class="sc">-</span>pasted content.</span>
<span id="cb19-138"><a href="#cb19-138" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-139"><a href="#cb19-139" aria-hidden="true" tabindex="-1"></a><span class="do">## 4. Expanding Contractions</span></span>
<span id="cb19-140"><a href="#cb19-140" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-141"><a href="#cb19-141" aria-hidden="true" tabindex="-1"></a>Now that we have normalized variations of apostrophes, we can properly handle contractions. In everyday language, we often shorten words<span class="sc">:</span> <span class="er">*</span>can’t<span class="sc">*</span>, <span class="sc">*</span>don’t<span class="sc">*</span>, <span class="sc">*</span>it’s<span class="sc">*</span>. These make speech and writing flow more easily, but they can cause confusion <span class="cf">for</span> Natural Language <span class="fu">Processing</span> (NLP) models. Expanding contractions, such as changing <span class="sc">*</span>can’t<span class="sc">*</span> to <span class="sc">*</span>cannot<span class="sc">*</span> or <span class="sc">*</span>it’s<span class="sc">*</span> to <span class="sc">*</span>it is<span class="sc">*</span>, helps bring clarity and consistency to the text because NLP models treat <span class="sc">*</span>don’t<span class="sc">*</span> and <span class="sc">*</span>do not<span class="sc">*</span> as completely different words, even though they mean the same thing. Also, words like <span class="sc">*</span>cant<span class="sc">*</span>, <span class="sc">*</span>doesnt<span class="sc">*</span>, and <span class="sc">*</span>whats<span class="sc">*</span> lose their meaning. Expanding contractions reduces this inconsistency and ensures that both forms are recognized as the same concept. Expanding it to <span class="sc">*</span>is not happy<span class="sc">*</span> makes the negative sentiment explicit, which is especially important <span class="cf">in</span> tasks like sentiment analysis.</span>
<span id="cb19-142"><a href="#cb19-142" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-143"><a href="#cb19-143" aria-hidden="true" tabindex="-1"></a>So, <span class="cf">while</span> it may seem like a small step, it often leads to cleaner data, leaner models, and more accurate results. First, however, we need to ensure that apostrophes are handled correctly. It<span class="st">'s not uncommon to encounter messy text where nonstandard characters are used in place of the straight apostrophe ('</span><span class="er">)</span>. Such inconsistencies are very common and can disrupt contraction expansion.</span>
<span id="cb19-144"><a href="#cb19-144" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-145"><a href="#cb19-145" aria-hidden="true" tabindex="-1"></a><span class="sc">|</span> Character <span class="sc">|</span> Unicode <span class="sc">|</span> Notes                                                   <span class="sc">|</span></span>
<span id="cb19-146"><a href="#cb19-146" aria-hidden="true" tabindex="-1"></a><span class="er">|</span><span class="sc">-------------</span><span class="er">|</span><span class="sc">-------------</span><span class="er">|</span><span class="sc">----------------------------------------------</span><span class="er">|</span></span>
<span id="cb19-147"><a href="#cb19-147" aria-hidden="true" tabindex="-1"></a><span class="er">|</span> <span class="st">`</span><span class="at">'</span><span class="st">`</span>       <span class="sc">|</span> U<span class="sc">+</span><span class="dv">0027</span>  <span class="sc">|</span> Standard straight apostrophe, used <span class="cf">in</span> most dictionaries <span class="sc">|</span></span>
<span id="cb19-148"><a href="#cb19-148" aria-hidden="true" tabindex="-1"></a><span class="er">|</span> <span class="st">`</span><span class="at">’</span><span class="st">`</span>       <span class="sc">|</span> U<span class="sc">+</span><span class="dv">2019</span>  <span class="sc">|</span> Right single quotation <span class="fu">mark</span> (curly apostrophe)          <span class="sc">|</span></span>
<span id="cb19-149"><a href="#cb19-149" aria-hidden="true" tabindex="-1"></a><span class="er">|</span> <span class="st">`</span><span class="at">‘</span><span class="st">`</span>       <span class="sc">|</span> U<span class="sc">+</span><span class="dv">2018</span>  <span class="sc">|</span> Left single quotation mark                              <span class="sc">|</span></span>
<span id="cb19-150"><a href="#cb19-150" aria-hidden="true" tabindex="-1"></a><span class="er">|</span> <span class="st">`</span><span class="at">ʼ</span><span class="st">`</span>       <span class="sc">|</span> U<span class="sc">+</span><span class="dv">02</span>BC  <span class="sc">|</span> Modifier letter apostrophe                              <span class="sc">|</span></span>
<span id="cb19-151"><a href="#cb19-151" aria-hidden="true" tabindex="-1"></a><span class="er">|</span> <span class="st">``</span> <span class="st">`</span><span class="at"> </span><span class="st">``</span><span class="at">   | U+0060  | Grave accent (sometimes typed by mistake)               |</span></span>
<span id="cb19-152"><a href="#cb19-152" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-153"><a href="#cb19-153" aria-hidden="true" tabindex="-1"></a><span class="at">Let's make sure that words like "don't" become "do not", by adding the following line to our code chunk:</span></span>
<span id="cb19-154"><a href="#cb19-154" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-155"><a href="#cb19-155" aria-hidden="true" tabindex="-1"></a><span class="st">```</span> r</span>
<span id="cb19-156"><a href="#cb19-156" aria-hidden="true" tabindex="-1"></a><span class="fu">replace_contraction</span>() <span class="sc">%&gt;%</span></span>
<span id="cb19-157"><a href="#cb19-157" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-158"><a href="#cb19-158" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-159"><a href="#cb19-159" aria-hidden="true" tabindex="-1"></a><span class="fu">## 5. Splitting Hashtags</span></span>
<span id="cb19-160"><a href="#cb19-160" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-161"><a href="#cb19-161" aria-hidden="true" tabindex="-1"></a>Hashtags are a powerful tool in social media and online communication, serving as a way to categorize content, highlight topics, and increase visibility. By prefixing a word or phrase with <span class="in">`#`</span>, users can link their posts to a broader conversation, making it easier for others to discover and engage with content on that topic. Hashtags also act as a keyword system, allowing researchers and analysts to track trends, measure sentiment, or analyze public discussions around specific themes. In text analysis, properly handling hashtags ensures that the meaningful content within them is captured, improving tokenization, searchability, and overall insights from the data. They effectively turn user-generated text into a structured source of topical information that can be leveraged for both social and analytical purposes.</span>
<span id="cb19-162"><a href="#cb19-162" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-163"><a href="#cb19-163" aria-hidden="true" tabindex="-1"></a>Hashtags are often written as one long string with no spaces, e.g., <span class="in">`#SeveranceIsFire`</span>. Splitting them into separate words not only makes it human-readable and easier to understand, but also ensure meaningful tokes and improves text analysis accuracy.</span>
<span id="cb19-164"><a href="#cb19-164" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-165"><a href="#cb19-165" aria-hidden="true" tabindex="-1"></a>While some researchers might want to separate them from the text for further analysis, we can also split concatenated words in hashtags or camelCase text by inserting a space between them. In our regex pattern hashtag_splitter, we have:</span>
<span id="cb19-166"><a href="#cb19-166" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-167"><a href="#cb19-167" aria-hidden="true" tabindex="-1"></a><span class="ss">-   </span><span class="in">`(?&lt;![#@])`</span>: negative lookbehind to avoid splitting right after <span class="in">`#`</span> or <span class="in">`@`</span>, preserving hashtags and mentions.</span>
<span id="cb19-168"><a href="#cb19-168" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-169"><a href="#cb19-169" aria-hidden="true" tabindex="-1"></a><span class="ss">-   </span><span class="in">`([a-z])([A-Z])`</span>: captures lowercase followed by uppercase letters, identifying camelCase word boundaries.</span>
<span id="cb19-170"><a href="#cb19-170" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-171"><a href="#cb19-171" aria-hidden="true" tabindex="-1"></a>We can call that pattern and use the string replacement function to adds the space between words while keeping the letters themselves intact, by adding the following to our code chunk:</span>
<span id="cb19-172"><a href="#cb19-172" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-173"><a href="#cb19-173" aria-hidden="true" tabindex="-1"></a><span class="in">``` r</span></span>
<span id="cb19-174"><a href="#cb19-174" aria-hidden="true" tabindex="-1"></a><span class="fu">str_replace_all</span>(hashtag_splitter, <span class="st">"</span><span class="sc">\\</span><span class="st">1 </span><span class="sc">\\</span><span class="st">2"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb19-175"><a href="#cb19-175" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-176"><a href="#cb19-176" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-177"><a href="#cb19-177" aria-hidden="true" tabindex="-1"></a>In simple terms, the <span class="in">`"\1 \2"`</span> inserts the first captured piece, adds a space, and then inserts the second captured piece.</span>
<span id="cb19-178"><a href="#cb19-178" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-179"><a href="#cb19-179" aria-hidden="true" tabindex="-1"></a>You might be asking, "wait a minute but what about the hastag (#) itself?". It is a valid question, but not to worry, we will take care of that later when handling symbols.</span>
<span id="cb19-180"><a href="#cb19-180" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-181"><a href="#cb19-181" aria-hidden="true" tabindex="-1"></a><span class="fu">## 6. Converting to Lowercase</span></span>
<span id="cb19-182"><a href="#cb19-182" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-183"><a href="#cb19-183" aria-hidden="true" tabindex="-1"></a>Having all text converted to lowercase will be our next step, by adding the following line to our code chunk:</span>
<span id="cb19-184"><a href="#cb19-184" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-185"><a href="#cb19-185" aria-hidden="true" tabindex="-1"></a><span class="in">``` r</span></span>
<span id="cb19-186"><a href="#cb19-186" aria-hidden="true" tabindex="-1"></a><span class="fu">str_to_lower</span>() <span class="sc">%&gt;%</span></span>
<span id="cb19-187"><a href="#cb19-187" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-188"><a href="#cb19-188" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-189"><a href="#cb19-189" aria-hidden="true" tabindex="-1"></a><span class="fu">## 7. Removing Mentions</span></span>
<span id="cb19-190"><a href="#cb19-190" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-191"><a href="#cb19-191" aria-hidden="true" tabindex="-1"></a>Continuing with our workflow, we will now handle direct mentions and usernames in our dataset, as they do not contribute relevant information to our analysis. We will use a function to replace all occurrences of usernames preceded. Since we have pre-populated the regular expression and stored it in the variable "mentions", <span class="in">`mentions &lt;- "@[A-Za-z0-9_]+"`</span> we will only need to add that we want to replace it with an empty string and remove them.</span>
<span id="cb19-192"><a href="#cb19-192" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-193"><a href="#cb19-193" aria-hidden="true" tabindex="-1"></a><span class="in">``` r</span></span>
<span id="cb19-194"><a href="#cb19-194" aria-hidden="true" tabindex="-1"></a><span class="fu">str_replace_all</span>(mentions, <span class="st">""</span>) <span class="sc">%&gt;%</span></span>
<span id="cb19-195"><a href="#cb19-195" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-196"><a href="#cb19-196" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-197"><a href="#cb19-197" aria-hidden="true" tabindex="-1"></a><span class="fu">## 8. Cleaning Punctuation, Symbols and Numbers</span></span>
<span id="cb19-198"><a href="#cb19-198" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-199"><a href="#cb19-199" aria-hidden="true" tabindex="-1"></a>Alright, time to remove punctuation and symbols, and then numbers.</span>
<span id="cb19-200"><a href="#cb19-200" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-201"><a href="#cb19-201" aria-hidden="true" tabindex="-1"></a>But first, last break it down, the punctuation regex pattern, where **`[[:punct:]]`** is character class in regex that matches any standard punctuation character, including: ! " <span class="sc">\#</span> \$ % &amp; ' ( ) <span class="sc">\*</span> + , - . / : ; <span class="sc">\&lt;</span> = <span class="sc">\&gt;</span> ? \@ <span class="sc">\[</span> &nbsp;<span class="sc">\]</span> \^ <span class="sc">\_</span> <span class="sc">\`</span> { <span class="sc">\|</span> } \~. To be safe and because our dataset is really messy, we added extra characters (<span class="in">`“”‘’–—…|+`</span>) to catch some special quotes, dashes, ellipsis, and symbols that <span class="in">`[[:punct:]]`</span> might miss. Calling that variable, we can remove them by adding to our code:</span>
<span id="cb19-202"><a href="#cb19-202" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-203"><a href="#cb19-203" aria-hidden="true" tabindex="-1"></a><span class="in">``` r</span></span>
<span id="cb19-204"><a href="#cb19-204" aria-hidden="true" tabindex="-1"></a><span class="fu">str_replace_all</span>(punctuation, <span class="st">" "</span>) <span class="sc">%&gt;%</span></span>
<span id="cb19-205"><a href="#cb19-205" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-206"><a href="#cb19-206" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-207"><a href="#cb19-207" aria-hidden="true" tabindex="-1"></a>Next, last clear some numbers by adding <span class="in">`[[:digit:]]+`</span>. This is the regex pattern matches any single digit (0–9) and <span class="in">`+`</span> means one or more digits in a row. So it matches sequences like <span class="in">`7`</span>, <span class="in">`42`</span>, <span class="in">`2025`</span>, etc:</span>
<span id="cb19-208"><a href="#cb19-208" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-209"><a href="#cb19-209" aria-hidden="true" tabindex="-1"></a><span class="in">``` r</span></span>
<span id="cb19-210"><a href="#cb19-210" aria-hidden="true" tabindex="-1"></a><span class="fu">str_replace_all</span>(<span class="st">"[[:digit:]]+"</span>, <span class="st">" "</span>) <span class="sc">%&gt;%</span></span>
<span id="cb19-211"><a href="#cb19-211" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-212"><a href="#cb19-212" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-213"><a href="#cb19-213" aria-hidden="true" tabindex="-1"></a><span class="fu">## 9. Handling Elongation</span></span>
<span id="cb19-214"><a href="#cb19-214" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-215"><a href="#cb19-215" aria-hidden="true" tabindex="-1"></a>In user-generated content, it’s common to see repeated letters used for emphasis (e.g., “Amaaaazing,” “Loooove”). For that, we have the regex pattern <span class="in">`repeated_chars &lt;- "(.)\1{2,}"`</span>, where:</span>
<span id="cb19-216"><a href="#cb19-216" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-217"><a href="#cb19-217" aria-hidden="true" tabindex="-1"></a><span class="ss">-   </span><span class="in">`(.)`</span>: captures group that matches any single character (except line breaks, depending on regex flavor). The <span class="in">`.`</span> is a wildcard. The parentheses <span class="in">`()`</span> capture whatever character matched for later reference.</span>
<span id="cb19-218"><a href="#cb19-218" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-219"><a href="#cb19-219" aria-hidden="true" tabindex="-1"></a><span class="ss">-   </span><span class="in">`\\1`</span>: refers to “whatever was matched by the first capturing group.” In other words, it matches the same character again.</span>
<span id="cb19-220"><a href="#cb19-220" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-221"><a href="#cb19-221" aria-hidden="true" tabindex="-1"></a><span class="ss">-   </span><span class="in">`{2,}`</span>: means “repeat the previous element at least 2 times.”</span>
<span id="cb19-222"><a href="#cb19-222" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-223"><a href="#cb19-223" aria-hidden="true" tabindex="-1"></a>Putting it together <span class="in">`(.)\\1{2,}`</span> matches any character that repeats 3 or more times consecutively. Why 3? Because the first occurrence is matched by <span class="in">`(.)`</span> and <span class="in">`{2,}`</span> requires at least 2 more repetitions, so total = 3+.</span>
<span id="cb19-224"><a href="#cb19-224" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-225"><a href="#cb19-225" aria-hidden="true" tabindex="-1"></a>Because the pattern is already in our workbook, we can simply add:</span>
<span id="cb19-226"><a href="#cb19-226" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-227"><a href="#cb19-227" aria-hidden="true" tabindex="-1"></a><span class="in">``` r</span></span>
<span id="cb19-228"><a href="#cb19-228" aria-hidden="true" tabindex="-1"></a><span class="fu">str_replace_all</span>(repeated_chars, <span class="st">"\1"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb19-229"><a href="#cb19-229" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-230"><a href="#cb19-230" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-231"><a href="#cb19-231" aria-hidden="true" tabindex="-1"></a>Can you guess what <span class="in">`"\1"`</span> does? It uses the character we captured earlier, keeping it in the text.</span>
<span id="cb19-232"><a href="#cb19-232" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-233"><a href="#cb19-233" aria-hidden="true" tabindex="-1"></a><span class="fu">## 10. Convert Emojis to Text</span></span>
<span id="cb19-234"><a href="#cb19-234" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-235"><a href="#cb19-235" aria-hidden="true" tabindex="-1"></a>Okay, now we’ll convert emojis into their text descriptions to make them machine-readable, using the emoji package to help with this step:</span>
<span id="cb19-236"><a href="#cb19-236" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-237"><a href="#cb19-237" aria-hidden="true" tabindex="-1"></a><span class="in">``` r</span></span>
<span id="cb19-238"><a href="#cb19-238" aria-hidden="true" tabindex="-1"></a><span class="co"># Load the emoji dictionary</span></span>
<span id="cb19-239"><a href="#cb19-239" aria-hidden="true" tabindex="-1"></a>emoji_dict <span class="ot">&lt;-</span> emo<span class="sc">::</span>jis[, <span class="fu">c</span>(<span class="st">"emoji"</span>, <span class="st">"name"</span>)]</span>
<span id="cb19-240"><a href="#cb19-240" aria-hidden="true" tabindex="-1"></a>emoji_dict</span>
<span id="cb19-241"><a href="#cb19-241" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-242"><a href="#cb19-242" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-243"><a href="#cb19-243" aria-hidden="true" tabindex="-1"></a>Take a look at the emoji dictionary we loaded into our RStudio environment. It’s packed with more emojis and some surprising meanings than you might expect. We will then write a separate function to deal with those emojis:</span>
<span id="cb19-244"><a href="#cb19-244" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-245"><a href="#cb19-245" aria-hidden="true" tabindex="-1"></a><span class="in">``` r</span></span>
<span id="cb19-246"><a href="#cb19-246" aria-hidden="true" tabindex="-1"></a><span class="co"># Function to replace emojis in text with their corresponding names</span></span>
<span id="cb19-247"><a href="#cb19-247" aria-hidden="true" tabindex="-1"></a>replace_emojis <span class="ot">&lt;-</span> <span class="cf">function</span>(text, emoji_dict) {</span>
<span id="cb19-248"><a href="#cb19-248" aria-hidden="true" tabindex="-1"></a>  <span class="fu">stri_replace_all_fixed</span>(</span>
<span id="cb19-249"><a href="#cb19-249" aria-hidden="true" tabindex="-1"></a>    <span class="at">str =</span> text,                  <span class="co"># The text to process</span></span>
<span id="cb19-250"><a href="#cb19-250" aria-hidden="true" tabindex="-1"></a>    <span class="at">pattern =</span> emoji_dict<span class="sc">$</span>emoji,  <span class="co"># The emojis to find</span></span>
<span id="cb19-251"><a href="#cb19-251" aria-hidden="true" tabindex="-1"></a>    <span class="at">replacement =</span> <span class="fu">paste0</span>(emoji_dict<span class="sc">$</span>name, <span class="st">" "</span>), <span class="co"># Their corresponding names</span></span>
<span id="cb19-252"><a href="#cb19-252" aria-hidden="true" tabindex="-1"></a>    <span class="at">vectorize_all =</span> <span class="cn">FALSE</span>        <span class="co"># element-wise replacement in a same string</span></span>
<span id="cb19-253"><a href="#cb19-253" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb19-254"><a href="#cb19-254" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb19-255"><a href="#cb19-255" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-256"><a href="#cb19-256" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-257"><a href="#cb19-257" aria-hidden="true" tabindex="-1"></a>Wait, we are not done yet! We still have to add the <span class="in">`replace_emojis`</span> function, based on our loaded dictionary, into our code chunk. This will replace the emojis with their corresponding text on our dataset:</span>
<span id="cb19-258"><a href="#cb19-258" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-259"><a href="#cb19-259" aria-hidden="true" tabindex="-1"></a><span class="in">``` r</span></span>
<span id="cb19-260"><a href="#cb19-260" aria-hidden="true" tabindex="-1"></a><span class="fu">replace_emojis</span>(emoji_dict) <span class="sc">%&gt;%</span></span>
<span id="cb19-261"><a href="#cb19-261" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-262"><a href="#cb19-262" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-263"><a href="#cb19-263" aria-hidden="true" tabindex="-1"></a><span class="sc">\[</span>FIXME ADD IMAGES<span class="sc">\]</span></span>
<span id="cb19-264"><a href="#cb19-264" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-265"><a href="#cb19-265" aria-hidden="true" tabindex="-1"></a>Neat! Let's re-run the code chunk and check it once again. With emojis taken care of, we can now apply the next and final normalization and noise reduction step.</span>
<span id="cb19-266"><a href="#cb19-266" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-267"><a href="#cb19-267" aria-hidden="true" tabindex="-1"></a><span class="fu">## 11. Dealing with Extraspaces</span></span>
<span id="cb19-268"><a href="#cb19-268" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-269"><a href="#cb19-269" aria-hidden="true" tabindex="-1"></a>After completing several normalization steps, we should also account for any extra spaces at the beginning or end of the text. These often come from inconsistent user input, copy-pasting, or formatting issues on different platforms. Let’s clean up these spaces before moving on to the next episode.</span>
<span id="cb19-270"><a href="#cb19-270" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-271"><a href="#cb19-271" aria-hidden="true" tabindex="-1"></a><span class="in">``` r</span></span>
<span id="cb19-272"><a href="#cb19-272" aria-hidden="true" tabindex="-1"></a><span class="fu">str_squish</span>()<span class="er">)</span></span>
<span id="cb19-273"><a href="#cb19-273" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-274"><a href="#cb19-274" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-275"><a href="#cb19-275" aria-hidden="true" tabindex="-1"></a>Putting every step together we should have the following code:</span>
<span id="cb19-276"><a href="#cb19-276" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-277"><a href="#cb19-277" aria-hidden="true" tabindex="-1"></a><span class="in">``` r</span></span>
<span id="cb19-278"><a href="#cb19-278" aria-hidden="true" tabindex="-1"></a><span class="co">#Create a new column for the output clean text</span></span>
<span id="cb19-279"><a href="#cb19-279" aria-hidden="true" tabindex="-1"></a>comments <span class="ot">&lt;-</span> comments <span class="sc">%&gt;%</span></span>
<span id="cb19-280"><a href="#cb19-280" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(</span>
<span id="cb19-281"><a href="#cb19-281" aria-hidden="true" tabindex="-1"></a>    <span class="at">text_cleaned =</span> text <span class="sc">%&gt;%</span></span>
<span id="cb19-282"><a href="#cb19-282" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Remove URLs first</span></span>
<span id="cb19-283"><a href="#cb19-283" aria-hidden="true" tabindex="-1"></a>      <span class="fu">str_replace_all</span>(url_pattern, <span class="st">""</span>) <span class="sc">%&gt;%</span></span>
<span id="cb19-284"><a href="#cb19-284" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Replace hidden/special characters with space</span></span>
<span id="cb19-285"><a href="#cb19-285" aria-hidden="true" tabindex="-1"></a>      <span class="fu">str_replace_all</span>(hidden_characters, <span class="st">" "</span>) <span class="sc">%&gt;%</span></span>
<span id="cb19-286"><a href="#cb19-286" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Standardize apostrophes</span></span>
<span id="cb19-287"><a href="#cb19-287" aria-hidden="true" tabindex="-1"></a>      <span class="fu">str_replace_all</span>(apostrophes, <span class="st">"'"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb19-288"><a href="#cb19-288" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Expand contractions (e.g., "don't" → "do not")</span></span>
<span id="cb19-289"><a href="#cb19-289" aria-hidden="true" tabindex="-1"></a>      <span class="fu">replace_contraction</span>() <span class="sc">%&gt;%</span></span>
<span id="cb19-290"><a href="#cb19-290" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Split camelCase hashtags (optional)</span></span>
<span id="cb19-291"><a href="#cb19-291" aria-hidden="true" tabindex="-1"></a>      <span class="fu">str_replace_all</span>(hashtag_splitter, <span class="st">"</span><span class="sc">\\</span><span class="st">1 </span><span class="sc">\\</span><span class="st">2"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb19-292"><a href="#cb19-292" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Convert to lowercase</span></span>
<span id="cb19-293"><a href="#cb19-293" aria-hidden="true" tabindex="-1"></a>      <span class="fu">str_to_lower</span>() <span class="sc">%&gt;%</span></span>
<span id="cb19-294"><a href="#cb19-294" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Remove mentions (@username)</span></span>
<span id="cb19-295"><a href="#cb19-295" aria-hidden="true" tabindex="-1"></a>      <span class="fu">str_replace_all</span>(mentions, <span class="st">""</span>) <span class="sc">%&gt;%</span></span>
<span id="cb19-296"><a href="#cb19-296" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Remove punctuation</span></span>
<span id="cb19-297"><a href="#cb19-297" aria-hidden="true" tabindex="-1"></a>      <span class="fu">str_replace_all</span>(punctuation, <span class="st">" "</span>) <span class="sc">%&gt;%</span></span>
<span id="cb19-298"><a href="#cb19-298" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Remove digits</span></span>
<span id="cb19-299"><a href="#cb19-299" aria-hidden="true" tabindex="-1"></a>      <span class="fu">str_replace_all</span>(<span class="st">"[[:digit:]]+"</span>, <span class="st">" "</span>) <span class="sc">%&gt;%</span></span>
<span id="cb19-300"><a href="#cb19-300" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Normalize repeated characters (e.g., loooove → love)</span></span>
<span id="cb19-301"><a href="#cb19-301" aria-hidden="true" tabindex="-1"></a>      <span class="fu">str_replace_all</span>(repeated_chars, <span class="st">"</span><span class="sc">\\</span><span class="st">1"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb19-302"><a href="#cb19-302" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Replace emojis with textual description (function - see above)</span></span>
<span id="cb19-303"><a href="#cb19-303" aria-hidden="true" tabindex="-1"></a>      <span class="fu">replace_emojis</span>(emoji_dict) <span class="sc">%&gt;%</span></span>
<span id="cb19-304"><a href="#cb19-304" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Remove extra whitespaces</span></span>
<span id="cb19-305"><a href="#cb19-305" aria-hidden="true" tabindex="-1"></a>      <span class="fu">str_squish</span>()</span>
<span id="cb19-306"><a href="#cb19-306" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb19-307"><a href="#cb19-307" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-308"><a href="#cb19-308" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-309"><a href="#cb19-309" aria-hidden="true" tabindex="-1"></a>Neat! Our normalization and noise reduction code chunk is complete, but don't forget to close the parentheses before running it! Let's see and compare the original "text column" compares to "text_cleaned".</span>
<span id="cb19-310"><a href="#cb19-310" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-311"><a href="#cb19-311" aria-hidden="true" tabindex="-1"></a><span class="fu">## One more thing</span></span>
<span id="cb19-312"><a href="#cb19-312" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-313"><a href="#cb19-313" aria-hidden="true" tabindex="-1"></a>Oh, no, if we look at row 1756 we will notice that we still have a waffle 🧇 emoji in that comment. Well, not too worry, while this emoji wasn't included in the original dictionary we used, we can still add it to it for automatic handling:</span>
<span id="cb19-314"><a href="#cb19-314" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-315"><a href="#cb19-315" aria-hidden="true" tabindex="-1"></a><span class="in">```{emoji_dict &lt;- emo::jis[, c("emoji", "name")]}</span></span>
<span id="cb19-316"><a href="#cb19-316" aria-hidden="true" tabindex="-1"></a><span class="in">emoji_dict &lt;- emoji_dict %&gt;% add_row("emoji" = "🧇", "name" = "waffle")</span></span>
<span id="cb19-317"><a href="#cb19-317" aria-hidden="true" tabindex="-1"></a><span class="in">emoji_dict</span></span>
<span id="cb19-318"><a href="#cb19-318" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-319"><a href="#cb19-319" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-320"><a href="#cb19-320" aria-hidden="true" tabindex="-1"></a>::: callout-note</span>
<span id="cb19-321"><a href="#cb19-321" aria-hidden="true" tabindex="-1"></a><span class="fu">## 🦾 Challenge (FIXME)</span></span>
<span id="cb19-322"><a href="#cb19-322" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-323"><a href="#cb19-323" aria-hidden="true" tabindex="-1"></a>Identify any remaining emoji that wasn’t converted and add it to the emoji dictionary.</span>
<span id="cb19-324"><a href="#cb19-324" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-325"><a href="#cb19-325" aria-hidden="true" tabindex="-1"></a>add_row(emoji = "🥹", name = "pleading face"</span>
<span id="cb19-326"><a href="#cb19-326" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb19-327"><a href="#cb19-327" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-328"><a href="#cb19-328" aria-hidden="true" tabindex="-1"></a>Let's re-run the code chunk and check how those emojis were taken care of. With normalization and noise reduction completed, we are now ready to move to the next preprocessing step: tokenization.</span>
<span id="cb19-329"><a href="#cb19-329" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-330"><a href="#cb19-330" aria-hidden="true" tabindex="-1"></a>::: {.callout-note icon="false"}</span>
<span id="cb19-331"><a href="#cb19-331" aria-hidden="true" tabindex="-1"></a><span class="fu">## 📑 Suggested Readings</span></span>
<span id="cb19-332"><a href="#cb19-332" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-333"><a href="#cb19-333" aria-hidden="true" tabindex="-1"></a>Bai, Q., Dan, Q., Mu, Z., &amp; Yang, M. (2019). A systematic review of emoji: Current research and future perspectives. *Frontiers in psychology*, *10*, <span class="ot">&lt;https://doi.org/10.3389/fpsyg.2019.02221&gt;</span></span>
<span id="cb19-334"><a href="#cb19-334" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-335"><a href="#cb19-335" aria-hidden="true" tabindex="-1"></a>Graham, P. V. (2024). Emojis: An Approach to Interpretation. *UC L. SF Commc'n and Ent. J.*, *46*, 123. <span class="ot">&lt;https://repository.uclawsf.edu/cgi/viewcontent.cgi?article=1850&amp;context=hastings_comm_ent_law_journal&gt;</span></span>
<span id="cb19-336"><a href="#cb19-336" aria-hidden="true" tabindex="-1"></a>:::</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></div>
</div></div></div></div></div>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p><img src="_static/images/RDS-logo.png" alt="UCSB Library Research Data Services logo" width="250"></p>
</div>   
    <div class="nav-footer-center">
<p>This website is built with <a href="https://quarto.org/">Quarto</a>, <a href="https://posit.co/">RStudio/Posit</a>, and <a href="https://cran.r-project.org/web/packages/webexercises/index.html">webexercises R package</a>. UCSB Library Research Data Services. <a href="https://creativecommons.org/licenses/by/4.0/deed.en">CC BY 4.0</a></p>
</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>